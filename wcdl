#!/usr/bin/env perl

#----------------------------------------------------------------------------------
# Project Name      - wcdl (Wallpaperscraft Downloader)
# Started On        - Sat 27 Apr 18:54:48 BST 2019
# Last Change       - Sat 14 Dec 18:47:49 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# NOTE: The web pages use UTF-8 encoding.
#----------------------------------------------------------------------------------

#TODO - Add a preview feature. Use ImageMagick.

use strict;
use warnings;
use autodie;
use LWP::Simple;
use LWP::UserAgent;
use Image::Magick; # <-- libimage-magick-perl
use List::MoreUtils 'uniq';
use X11::Protocol;
use File::Basename qw{dirname basename};
use File::Path 'make_path';
use File::Temp;
use POSIX 'ceil';
use Term::ANSIColor qw{GREEN RED BOLD RESET YELLOW};
use TFL; # <-- libtfl-perl (>= 2019-05-07)

my $_VERSION_ = "2019-05-11";
my $_PROJECT_ = basename($0);

my $DOM = 'https://wallpaperscraft.com';
my $GH_URL = "https://github.com/terminalforlife/$_PROJECT_/raw/master/version";
my $LOCAL_DIR = "$ENV{HOME}/.local/share/$_PROJECT_";
my $CACHE_DIR = "$LOCAL_DIR/cache";
my $CACHE_CATS = "$CACHE_DIR/categories";
my $CACHE_PAGES = "$CACHE_DIR/pages";
my $HOMEPAGE = "$CACHE_DIR/homepage";

sub USAGE{
	my $INFO = qq{            @{[uc($_PROJECT_)]} ($_VERSION_)
		            Written by terminalforlife <terminalforlife\@yahoo.com>

		            Extensive Perl downloader for Wallpaperscraft.

		SYNTAX:     $_PROJECT_ [OPTS] CATEGORY PAGE

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --colorless             - Don't color output with escape sequences.
		            --links-only|-O         - Just output the direct download links.
		            --show-categories       - List categories, images, and pages.
		            --show-resolutions      - List the site's available resolutions.
		            --resolution|-r XY      - Where XY is, for example: '1920x1080'
		            --filter|-f TAG         - Omit images not matching TAG.
		            --dest|-D PATH          - Specify where the files will be saved.
		            --png|-p                - Save image in PNG format, instead of JPG.
		            --no-cache|-N           - Run without using or keeping cache.
		            --repopulate            - Repopulate all processed cache files.
		            --clobber               - Overwrite ALL processed image files.

		NOTE:       Page numbers can be given in ranges, or single digits, as shown below.

		DISPLAY:    By default, $_PROJECT_ will try to detect the current display resolution.

		            If you're using a multi-monitor setup, only the first discovered
		            (connected) display will be processed; in this case, you might be
		            better off picking your resolution manually, with the
		            '--resolution|-r' flags.

		EXAMPLE:    $_PROJECT_ -D ~/Downloads -N nature '2 8 10'
		            $_PROJECT_ --links-only abstract '1 3 8 10-24 105'
		            $_PROJECT_ --repopulate --clobber -O cars 1-5
		            $_PROJECT_ -O -f cat -f snow animals 1-100

		SITE:       $DOM
	};

	print($INFO =~ s/\t//gr)
}

my $RES = '';
my $DEST = './';
my $COLOR = 1;
my $CLOBBER = 0;
my $SAVE_AS_PNG = 0;
my $REPOPULATE = 0;
my $LINKS_ONLY = 0;
my $LIST_CATS = 0;
my $NO_CACHE = 0;
my $FILTER = 0;
my @FILTER_MATCH;
my $SHOW_RES = 0;

while(defined($ARGV[0])){
	if($ARGV[0] =~ /^(--help|-h|-\?)$/){
		USAGE(); exit 0
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print("$_VERSION_\n"); exit 0
	}elsif($ARGV[0] =~ /^--colorless$/){
		$COLOR = 0
	}elsif($ARGV[0] =~ /^(--links-only|-O)$/){
		$LINKS_ONLY = 1
	}elsif($ARGV[0] =~ /^--show-categories$/){
		$LIST_CATS = 1
	}elsif($ARGV[0] =~ /^--show-resolutions$/){
		$SHOW_RES = 1
	}elsif($ARGV[0] =~ /^(--resolution|-r)$/){
		shift(@ARGV);

		if($ARGV[0] =~ /^[0-9]+x[0-9]+$/){
			$RES = $ARGV[0]
		}else{
			TFL::FAIL(1, __LINE__, "Invalid resolution chosen.")
		}
	}elsif($ARGV[0] =~ /^(--filter|-f)$/){
		shift(@ARGV);

		$FILTER = 1;
		push(@FILTER_MATCH, $ARGV[0])
	}elsif($ARGV[0] =~ /^(--png|-p)$/){
		$SAVE_AS_PNG = 1
	}elsif($ARGV[0] =~ /^(--dest|-D)$/){
		shift(@ARGV);

		if(-d $ARGV[0]){
			if($ARGV[0] !~ /\/$/){
				$DEST = $ARGV[0] . '/'
			}else{
				$DEST = $ARGV[0]
			}
		}else{
			TFL::FAIL(1, __LINE__, "Directory not found.")
		}
	}elsif($ARGV[0] =~ /^--repopulate$/){
		$REPOPULATE = 1
	}elsif($ARGV[0] =~ /^--clobber$/){
		$CLOBBER = 1
	}elsif($ARGV[0] =~ /^(--no-cache|-N)$/){
		$NO_CACHE = 1
	}elsif($ARGV[0] =~ /^-/){
		TFL::FAIL(1, __LINE__, "Incorrect argument(s) specified")
	}else{
		last
	}

	shift(@ARGV)
}

#--------------------------------------------------------------------------UA SETUP

my $UA = LWP::UserAgent->new();
$UA->max_redirect(1);
$UA->timeout(10);
$UA->protocols_allowed(['http', 'https']);
$UA->agent('Mozilla/5.0');

#-----------------------------------------------------------------PRIMARY FUNCTIONS

my $TMP; # <-- Set scope here, for later cleanup.
sub DL_PAGE{
	if(not $NO_CACHE){
		if((not $REPOPULATE) && (-f $_[0])){
			return(1)
		}elsif($REPOPULATE or not -f $_[0]){
			my $DIR = dirname($_[0]);
			make_path($DIR) unless -d $DIR;

			# Extra -f condition because file doesn't always exist.
			unlink($_[0]) if $REPOPULATE and -f $_[0];

			open(my $FH, '>:encoding(UTF-8)', $_[0]);

			my $DATA = $UA->get($_[1]);
			if($DATA->is_success()){
				print($FH $DATA->decoded_content())
			}else{
				unlink($_[0]);
				TFL::FAIL(1, __LINE__, "Unable to fetch and cache page data.")
			}

			close($FH)
		}
	}elsif($NO_CACHE){
		# Ignoring the first index to ensure no cache overwrites.

		if($REPOPULATE){
			TFL::FAIL(1, __LINE__, "Told to repopulate, but '--no-cache|N' is enabled")
		}

		my $FH = File::Temp->new(UNLINK => 0, SUFFIX => '_{$_PROJECT_}.tmp');
		binmode($FH, ':utf8'); # <-- Ensure temp file uses UTF-8 encoding.
		$TMP = $FH->filename();

		my $DATA = $UA->get($_[1]);
		if($DATA->is_success()){
			print($FH $DATA->decoded_content())
		}else{
			unlink($_[1]);
			TFL::FAIL(1, __LINE__, "Unable to fetch page data.")
		}

		close($FH)
	}
}

sub DL_IMAGE{
	return(1) if -f $_[0] and not $CLOBBER;

	open(my $FH, '>', $_[0]);

	my $DATA = $UA->get($_[1]);
	if($DATA->is_success()){
		print($FH $DATA->decoded_content());
	}else{
		if($COLOR){
			print(BOLD . RED . "[!]" . RESET);
		}else{
			print("[!]");
		}

		unlink($_[0]);
		return(1)
	}

	close($FH);

	if($SAVE_AS_PNG){
		my $IMAGE_OBJ = Image::Magick->new();
		$IMAGE_OBJ->Read($_[0]);
		$IMAGE_OBJ->Write($_[0] =~ s/\.jpg$/.png/r);
		unlink($_[0]) # <-- Remove the original after conversion.
	}
}

#--------------------------------------------------------------RESOLUTION DETECTION

if(length($RES) == 0){
	my $X11 = X11::Protocol->new();
	my $X = $X11->{screens}[0]{width_in_pixels};
	my $Y = $X11->{screens}[0]{height_in_pixels};
	$RES = $X . 'x' . $Y
}

#------------------------------------------------------CATEGORY & HOMEPAGE HANDLING

DL_PAGE($HOMEPAGE, $DOM);
open(my $FH, '<:encoding(UTF-8)', $HOMEPAGE);

my %CATNUMS;
my @RESOLUTIONS;
while(<$FH>){
	chomp($_);

	# Generate hash keys and their numeric values.
	if($_ =~ /class="filter__count"/){
		my @LINE = split('<', $_);
		my $CAT = $LINE[0] =~ s/(\s+|<.*$)//r;

		if($CAT !~ /60 Favorites$/){
			# Site not updated URL after name change.
			$CAT = 'hi-tech' if $CAT eq "Technologies";

			my $NUM = $LINE[1] =~ s/^.*>//gr;
			$CATNUMS{lc($CAT) =~ s/\s/_/gr} = $NUM
		}
	}elsif($_ =~ /value="[0-9]+x[0-9]+"/){
		my @LINE = split(' ', $_);
		push(@RESOLUTIONS, $LINE[1] =~ s/("|value=)//gr)
	}
}

close($FH);
unlink($TMP) if $NO_CACHE;

if($SHOW_RES){
	print("$_\n") foreach @RESOLUTIONS;
	exit 0
}

if($LIST_CATS){
	if($COLOR){
		printf(
			BOLD . GREEN . "%-14s %s %s\n" . RESET,
			"CATEGORY", "IMAGES", "PAGES"
		);
	}else{
		printf("%-14s %s %s\n", "CATEGORY", "IMAGES", "PAGES");
	}

	foreach(keys(%CATNUMS)){
		my $PAGE_TTL = ceil($CATNUMS{$_});

		printf(
			"%-14s %6d %d\n",
			$_, $CATNUMS{$_},
			ceil($PAGE_TTL / 15)
		)
	}

	exit 0
}

if(($ARGV[0]) and not(exists($CATNUMS{$ARGV[0]}))){
	TFL::FAIL(1, __LINE__, "Invalid category provided.")
}

#--------------------------------------------------------------PROCESS PAGE NUMBERS

my @PAGES;
unless($ARGV[1]){
	TFL::FAIL(1, __LINE__, "At least one (non-0) page must be provided.")
}else{
	my @PAGE_NUM_LIST = split(' ', $ARGV[1]);
	foreach(@PAGE_NUM_LIST){
		if($_ =~ /^([1-9]|[1-9][0-9]+)$/){
			push(@PAGES, $_)
		}elsif($_ =~ /^[0-9]+-[0-9]+$/){
			# Process ranges, like 1-4, which would output '1 2 3 4'.
			my ($START, $END) = split('-', $_);
			my @NUMS = ($START..$END);
			push(@PAGES, $_) foreach @NUMS
		}else{
			TFL::FAIL(1, __LINE__, "Invalid page number detected.")
		}
	}
}

#-----------------------------------------------------------------IMAGE DOWNLOADING

my $DL_LINK = 'https://images.wallpaperscraft.com/image';

foreach(@PAGES){
	my $DL_FH;

	# Check the user didn't enter too high a page number, by deviding the total
	# number of images (hence the hash) for the chosen category, by 15. Must
	# round up with ceil() (POSIX), as the final page may display 1-15 images.
	my $TOTAL_IMAGES_INTO_PAGES = ceil($CATNUMS{$ARGV[0]} / 15);
	if($_ > $TOTAL_IMAGES_INTO_PAGES){
		TFL::FAIL(1, __LINE__, "Page '$_' is out of range.")
	}

	if(length($RES) > 0){
		my $FOUND_RESOLUTION = 0;
		foreach(@RESOLUTIONS){
			if($_ eq $RES){
				$FOUND_RESOLUTION = 1;
				last
			}
		}

		unless($FOUND_RESOLUTION){
			TFL::FAIL(1, __LINE__, "Resolution not supported.")
		}
	}

	DL_PAGE("$CACHE_CATS/$ARGV[0]/$RES/$_", "$DOM/catalog/$ARGV[0]/page$_");

	if(not $NO_CACHE){
		open($DL_FH, '<:encoding(UTF-8)', "$CACHE_CATS/$ARGV[0]/$RES/$_");
	}elsif($NO_CACHE){
		open($DL_FH, '<:encoding(UTF-8)', "$TMP");
	}

	my $ID;
	my $TAGS_ID;
	my $FULL_LINK;
	while(<$DL_FH>){
		chomp($_);

		if($_ =~ /src="https:/ and $_ =~ /class="wallpapers__image"/){
			my @LINE = split(' ', $_);

			$TAGS_ID = $LINE[2] =~ s/(^src=".*\/|"|_[0-9]+x[0-9]+\.jpg"$)//gr;
			$ID = $TAGS_ID =~ s/^.*_//gr;
			$FULL_LINK = "$DL_LINK/${TAGS_ID}_$RES.jpg";

			# For the --filter|-f feature. Multiple of these flags can
			# be used to further narrow down the desired image.
			if($FILTER){
				my $FILTER_COUNT = 0;
				my $TAGS = $TAGS_ID =~ s/_[0-9]+$//r;
				foreach(@FILTER_MATCH){
					if($TAGS !~ /$_/){
						next
					}else{
						$FILTER_COUNT += 1
					}
				}

				# If the total number of matches equal the amount
				# of array indices, in a human-readable way, then
				# skip to the next image.
				next if $FILTER_COUNT < $#FILTER_MATCH + 1
			}

			if($LINKS_ONLY){
				print("$FULL_LINK\n")
			}else{
				if($COLOR){
					print(
						BOLD . YELLOW . "FILE:" . RESET .
						" '${TAGS_ID}_$RES.jpg' "
					);
				}else{
					print("FILE: '${TAGS_ID}_$RES.jpg' ");
				}

				DL_IMAGE("$DEST/${TAGS_ID}_$RES.jpg", $FULL_LINK);
				print("\n")
			}
		}
	}

	unlink($TMP) if $NO_CACHE
}
