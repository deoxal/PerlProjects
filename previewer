#!/usr/bin/perl

#----------------------------------------------------------------------------------
# Project Name      - perlmisc/previewer
# Started On        - Mon 22 Apr 01:30:36 BST 2019
# Last Change       - Sat  4 May 00:41:35 BST 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use Text::Wrap;
use LWP::UserAgent;
use Term::ReadKey 'GetTerminalSize';

my $_VERSION_ = "2019-05-04";

sub FAIL{
	printf("[L%0.4d] ERROR: %s\n", $_[1], $_[2]);
	if($_[0] == 1){exit 1}
}

#my $DB_SITE = 'https://community.linuxmint.com/data/new-reviews.list';
my $DB_SITE = 'https://community.linuxmint.com/data/reviews.list';

sub USAGE{
	my $HELP = qq{	            PREVIEWER ($_VERSION_)
		            Written by terminalforlife (terminalforlife\@yahoo.com)

		            Perl program to pretty-print Linux Mint package reviews.

		SYNTAX:     previewer [OPTS] PACKAGE RATING

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --summary|-S            - Conclude the reviews with a summary.
		            --show-all|-a           - Show all reviews, regardless of rating.
		            --boring|-b             - Omit these ASCII psuedo-borders.
		            --user|-u NAME          - Only show review(s) by NAME user.
		            --db-update             - Download and update the database.
		            --db-file PATH          - Instead, use this database file.

		NOTE:       Although previewer uses Linux Mint's review and rating database, it can
		            still prove useful in Debian, Ubuntu, and their other derivatives, -
		            albeit with inaccuracies.

		            If you specifiy your own database file, it MUST adhere to the same
		            formatting as the official one, lest previewer wind up a buggy mess.

		            For example:

		              PKG~~~ID~~~USER~~~RATING~~~REVIEW

		            Each field must be separated by three tildes, without any quotes.

		            Previewer is a Perl fork of and vast improvement over the original -
		            shell program, 'reviewer', written also by 'terminalforlife'.

		FILE:       Unless told otherwise, the database is stored here:

		              \$HOME/.config/reviewer.db

		SITE:       $DB_SITE
	};

	print(split("\t", $HELP))
}

my $IFUSER = '';
my $ARGLESS = 0;
my $BORING = 0;
my $SHOW_ALL = 0;
my $UPDATE_DB = 0;
my $SHOW_STATS = 0;
my $P1 = '+'; my $P2 = '|';
my $DATABASE = "$ENV{HOME}/.config/reviewer.db";

while($ARGV[0]){
	if($ARGV[0] =~ /^(--help|-h|-\?)$/){
		USAGE;
		exit 0
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print("$_VERSION_\n");
		exit 0
	}elsif($ARGV[0] =~ /^(--summary|-S)$/){
		$SHOW_STATS = 1
	}elsif($ARGV[0] =~ /^(--show-all|-a)$/){
		$SHOW_ALL = 1
	}elsif($ARGV[0] =~ /^--db-update$/){
		$UPDATE_DB = 1
	}elsif($ARGV[0] =~ /^--db-file$/){
		shift(@ARGV);
		$DATABASE = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--user|-u)$/){
		shift(@ARGV);
		$IFUSER = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--boring|-b)$/){
		$BORING = 1
	}elsif($ARGV[0] =~ /^-.*/){
		FAIL(1, __LINE__, "Incorrect argument(s) specified.")
	}else{
		last
	}

	shift(@ARGV)
}

if(not $ARGV[0] and not $ARGV[1]){$ARGLESS = 1}

unless($UPDATE_DB or length($IFUSER) > 0 or ($SHOW_ALL and $ARGLESS)){
	if($SHOW_ALL and not $ARGV[0]){
		FAIL(1, __LINE__, "Missing package name.")
	}

	if($ARGV[1]){
		if($SHOW_ALL and $ARGV[1] !~ /^[1-5]{1}$/){
			FAIL(1, __LINE__, "Invalid rating provided.")
		}elsif($SHOW_ALL){
			FAIL(1, __LINE__, "Told to show all, but provided a rating.")
		}
	}else{
		unless($SHOW_ALL){
			FAIL(1, __LINE__, "A rating is by default required.")
		}
	}
}

if(not(-f $DATABASE and -r $DATABASE) and $UPDATE_DB){
	FAIL(1, __LINE__, "Database file missing or inaccessible.")
}elsif(-z $DATABASE and $UPDATE_DB){
	FAIL(1, __LINE__, "Database file is empty.")
}elsif($UPDATE_DB){
	open(my $FH, '>', $DATABASE);

	my $UA = LWP::UserAgent->new();
	$UA->agent('Mozilla/5.0');
	my $BUFFER = $UA->get($DB_SITE)->decoded_content;
	print($FH $BUFFER);

	close($FH);

	exit 0
}

$Text::Wrap::columns = @{[GetTerminalSize]}[0];

open(my $FH, '<', $DATABASE);
my @FILE_DATA = <$FH>;
close($FH);

my $STAR1_COUNT = 0;
my $STAR2_COUNT = 0;
my $STAR3_COUNT = 0;
my $STAR4_COUNT = 0;
my $STAR5_COUNT = 0;
my $TTL_COUNT = 0;
my $COUNT = 0;

sub INC_VARS{ # <-- $DATA[0] is passed here.
	$STAR1_COUNT++ if $_[0] == 1;
	$STAR2_COUNT++ if $_[0] == 2;
	$STAR3_COUNT++ if $_[0] == 3;
	$STAR4_COUNT++ if $_[0] == 4;
	$STAR5_COUNT++ if $_[0] == 5
}

sub SHOW{
	printf(
		"%d/5 ('%s')\n $P1\n%s $P1\n",
		$_[1], $_[2], wrap(" $P2 ", " $P2 ", $_[0])
	)
}

if($BORING){$P1 = ' '; $P2 = ' '}

my $PACK_OLD;
foreach(@FILE_DATA){
	my @LINE = split("~~~", $_);

	my $PACK = $LINE[0];
	my $RATE = $LINE[3];
	my $SAID = $LINE[4];
	my $USER = $LINE[2];

	my @DATA = ($RATE, $SAID, $USER);

	if(length($IFUSER) > 0){ # <-- Go by users.
		if(not $ARGV[0]){
			if($IFUSER eq $USER){
				$COUNT++;
				$TTL_COUNT++;
				INC_VARS($DATA[0]);
				print("\n > '$PACK'\n\n");
				SHOW($DATA[1], $DATA[0], $DATA[2]);
			}
		}elsif($PACK eq $ARGV[0]){
			if($IFUSER eq $USER){
				$COUNT++;
				$TTL_COUNT++;
				INC_VARS($DATA[0]);
				SHOW($DATA[1], $DATA[0], $DATA[2]);
			}
		}
	}elsif($ARGV[0]){ # <-- Go by packages.
		if($PACK eq $ARGV[0]){
			$TTL_COUNT++;
			INC_VARS($DATA[0]);

			if($SHOW_ALL){
				$COUNT++;
				SHOW($DATA[1], $DATA[0], $DATA[2])
			}elsif(($ARGV[1]) and ($DATA[0] == $ARGV[1])){
				$COUNT++;
				SHOW($DATA[1], $DATA[0], $DATA[2])
			}
		}
	}elsif($SHOW_ALL and $ARGLESS){ # <-- Just show all reviews.
		$COUNT++;
		$TTL_COUNT++;
		INC_VARS($DATA[0]);

		# Ensure print isn't unnecessarily repeated.
		if($PACK_OLD and $PACK_OLD ne $PACK){
			print("\n > '$PACK'\n\n");
		}elsif(not $PACK_OLD){
			print("\n > '$PACK'\n\n");
		}

		# When these aren't the same, next time, show what it is.
		$PACK_OLD = $PACK;

		SHOW($DATA[1], $DATA[0], $DATA[2])
	}
}

if($COUNT == 0){
	print("Uh-oh! ...no reviews were found.\n");
	exit(1)
}

if($SHOW_STATS){
	sub SHOW2{
		my $BUF = qq{
			 $_[1]$_[2]
			 $_[0] Reviews:     $COUNT/$TTL_COUNT
			 $_[0]
			 $_[0] Total 5/5:   $STAR5_COUNT
			 $_[0] Total 4/5:   $STAR4_COUNT
			 $_[0] Total 3/5:   $STAR3_COUNT
			 $_[0] Total 2/5:   $STAR2_COUNT
			 $_[0] Total 1/5:   $STAR1_COUNT
			 $_[1]$_[2]
		};

		print(split("\t", $BUF))
	}

	$BORING ? SHOW2("|", "+", ">") : SHOW2(" ", " ", " ")
}
