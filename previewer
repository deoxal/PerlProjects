#!/usr/bin/perl

#----------------------------------------------------------------------------------
# Project Name      - perlmisc/previewer
# Started On        - Mon 22 Apr 01:30:36 BST 2019
# Last Change       - Thu 25 Apr 21:16:57 BST 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use Text::Wrap;

my $_VERSION_ = "2019-04-25";

sub FAIL{
	printf("[L%0.4d] ERROR: %s\n", $_[1], $_[2]);
	if($_[0] == 1){exit 1}
}

my $DB_SITE = 'https://community.linuxmint.com/data/new-reviews.list';

sub USAGE{
	my $HELP = qq{	            PREVIEWER ($_VERSION_)
		            Written by terminalforlife (terminalforlife\@yahoo.com)

		            Perl fork of the slower, shell counterpart, 'reviewer'.

		SYNTAX:     previewer [OPTS] PACKAGE RATING

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --summary|-S            - Conclude the reviews with a summary.
		            --show-all|-a           - Show all reviews, regardless of rating.
		            --boring|-b             - Omit these ASCII psuedo-borders.
		            --db-update             - Download and update the database.
		            --db-file PATH          - Instead, use this database file.

		NOTE:       Although previewer uses Linux Mint's review and rating database, it can
		            still prove useful in Debian and Ubuntu, albeit with inaccuracies.

		            If you specifiy your own database file, it MUST adhere to the same
		            formatting as the official one, lest previewer wind up a buggy mess.

		            For example:

		              PKG~~~ID~~~USER~~~RATING~~~REVIEW

		            Each field must be separated by three tildes, without any quotes.

		FILE:       Unless told otherwise, the database is stored here:

		              \$HOME/.config/reviewer.db

		SITE:       $DB_SITE
	};

	print(split("\t", $HELP))
}

my $BORING = "False";
my $UPDATE_DB = "False";
my $SHOW_STATS = "False";
my $SHOW_ALL = "False";
my $DATABASE = "$ENV{HOME}/.config/reviewer.db";

while($ARGV[0]){
	if($ARGV[0] =~ /^(--help|-h|-\?)$/){
		USAGE;
		exit 0
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print("$_VERSION_\n");
		exit 0
	}elsif($ARGV[0] =~ /^(--summary|-S)$/){
		$SHOW_STATS = "True"
	}elsif($ARGV[0] =~ /^(--show-all|-a)$/){
		$SHOW_ALL = "True"
	}elsif($ARGV[0] =~ /^--db-update$/){
		$UPDATE_DB = "True"
	}elsif($ARGV[0] =~ /^--db-file$/){
		shift(@ARGV);
		$DATABASE = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--boring|-b)$/){
		$BORING = "True"
	}elsif($ARGV[0] =~ /^-.*/){
		FAIL(1, __LINE__, "Incorrect argument(s) specified.")
	}else{
		last
	}

	shift(@ARGV)
}

unless($UPDATE_DB eq "True"){
	if($ARGV[1]){
		if($ARGV[1] !~ /^[1-5]{1}$/ && $SHOW_ALL eq "False"){
			FAIL(1, __LINE__, "Invalid rating provided.")
		}elsif($SHOW_ALL eq "True"){
			FAIL(1, __LINE__, "Told to show all, but provided a rating.")
		}
	}else{
		FAIL(1, __LINE__, "A rating is by default required.")
	}
}

if(! -x "/usr/bin/tput"){
	FAIL(1, __LINE__, "Dependency '/usr/bin/tput' not met.")
}

if(not(-f $DATABASE && -r $DATABASE) && ($UPDATE_DB eq "False")){
	FAIL(1, __LINE__, "Database file missing or inaccessible.")
}elsif(-z $DATABASE && $UPDATE_DB ne "True"){
	FAIL(1, __LINE__, "Database file is empty.")
}elsif($UPDATE_DB eq "True"){
	use LWP::UserAgent;

	open(my $FH, '>', $DATABASE);

	my $UA = LWP::UserAgent->new();
	$UA->agent('Mozilla/5.0');
	my $BUFFER = $UA->get($DB_SITE)->decoded_content;
	print($FH $BUFFER);

	close($FH);

	exit 0
}

$Text::Wrap::columns = `/usr/bin/tput cols`;

open(my $FH, '<', $DATABASE);

my $STAR1_COUNT = 0;
my $STAR2_COUNT = 0;
my $STAR3_COUNT = 0;
my $STAR4_COUNT = 0;
my $STAR5_COUNT = 0;
my $TTL_COUNT = 0;
my $COUNT = 0;

while(<$FH>){
	my @LINE = split("~~~", $_);

	my $PACK = $LINE[0];
	my $RATE = $LINE[3];
	my $SAID = $LINE[4];
	my $USER = $LINE[2];

	if($PACK eq $ARGV[0]){
		$TTL_COUNT += 1;

		my @DATA = ($RATE, $SAID, $USER);
		if($DATA[0] == 1){$STAR1_COUNT += 1}
		if($DATA[0] == 2){$STAR2_COUNT += 1}
		if($DATA[0] == 3){$STAR3_COUNT += 1}
		if($DATA[0] == 4){$STAR4_COUNT += 1}
		if($DATA[0] == 5){$STAR5_COUNT += 1}

		sub SHOW{
			printf(
				"%d/5 ('%s')\n $_[0]\n%s $_[0]\n",
				$_[3], $_[4],
				wrap(" $_[1] ", " $_[1] ", $_[2])
			)
		}

		if($SHOW_ALL eq "True"){
			if($BORING eq "True"){
				SHOW(" ", " ", $DATA[1], $DATA[0], $DATA[2])
			}else{
				SHOW("+", "|", $DATA[1], $DATA[0], $DATA[2])
			}
		}elsif($DATA[0] == $ARGV[1]){
			$COUNT++;

			if($BORING eq "True"){
				SHOW(" ", " ", $DATA[1], $DATA[0], $DATA[2])
			}else{
				SHOW("+", "|", $DATA[1], $DATA[0], $DATA[2])
			}
		}
	}
}

close($FH);

if($SHOW_STATS eq "True"){
	sub SHOW2{
		my $BUF = qq{
			 $_[1]$_[2]
			 $_[0] Reviews:     $COUNT/$TTL_COUNT
			 $_[0]
			 $_[0] Total 5/5:   $STAR5_COUNT
			 $_[0] Total 4/5:   $STAR4_COUNT
			 $_[0] Total 3/5:   $STAR3_COUNT
			 $_[0] Total 2/5:   $STAR2_COUNT
			 $_[0] Total 1/5:   $STAR1_COUNT
			 $_[1]$_[2]
		};

		print(split("\t", $BUF))
	}

	$BORING ne "True" ? SHOW2("|", "+", ">") : SHOW2(" ", " ", " ")
}
