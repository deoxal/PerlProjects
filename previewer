#!/usr/bin/perl

#----------------------------------------------------------------------------------
# Project Name      - perlmisc/previewer
# Started On        - Mon 22 Apr 01:30:36 BST 2019
# Last Change       - Wed 24 Apr 13:48:59 BST 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use Text::Wrap;

my $_VERSION_ = "2019-04-24";

sub FAIL{
	printf("[L%0.4d] ERROR: %s\n", $_[1], $_[2]);
	if($_[0] == 1){exit 1}
}

my $DB_SITE = 'https://community.linuxmint.com/data/new-reviews.list';

sub USAGE{
	my $HELP = qq{	            PREVIEWER ($_VERSION_)
		            Written by terminalforlife (terminalforlife\@yahoo.com)

		            Perl fork of the slower, shell counterpart, 'reviewer'.

		SYNTAX:     previewer [OPTS] PACKAGE RATING

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --summary|-S            - Conclude the reviews with a summary.
		            --boring|-b             - Omit these ASCII psuedo-borders.
		            --db-update             - Download and update the database.
		            --db-file PATH          - Instead, use this database file.

		NOTE:       Although previewer uses Linux Mint's review and rating database, it can
		            still prove useful in Debian and Ubuntu, albeit with inaccuracies.

		            If you specifiy your own database file, it MUST adhere to the same
		            formatting as the official one, lest previewer wind up a buggy mess.

		            For example:

		              PKG~~~ID~~~USER~~~RATING~~~REVIEW

		            Each field must be separated by three tildes, without any quotes.

		FILE:       Unless told otherwise, the database is stored here:

		              \$HOME/.config/reviewer.db

		SITE:       $DB_SITE
	};

	print(split("\t", $HELP))
}

my $BORING = "False";
my $UPDATE_DB = "False";
my $SHOW_STATS = "False";
my $DATABASE = "$ENV{HOME}/.config/reviewer.db";

if(@ARGV){
	while($ARGV[0]){
		if($ARGV[0] =~ /^(--help|-h|-\?)$/){
			USAGE;
			exit 0
		}elsif($ARGV[0] =~ /^(--version|-v)$/){
			print("$_VERSION_\n");
			exit 0
		}elsif($ARGV[0] =~ /^(--summary|-S)$/){
			$SHOW_STATS = "True"
		}elsif($ARGV[0] =~ /^--db-update$/){
			$UPDATE_DB = "True"
		}elsif($ARGV[0] =~ /^--db-file$/){
			shift(@ARGV);
			$DATABASE = $ARGV[0]
		}elsif($ARGV[0] =~ /^(--boring|-b)$/){
			$BORING = "True"
		}elsif($ARGV[0] =~ /^-.*/){
			FAIL(1, __LINE__, "Incorrect argument(s) specified.")
		}else{
			last
		}

		shift(@ARGV)
	}

	unless($UPDATE_DB eq "True"){
		if(! $ARGV[0]){
			FAIL(1, __LINE__, "A package name must be provided.")
		}elsif((! $ARGV[1]) || ($ARGV[1] !~ /^[1-5]{1}$/)){
			FAIL(1, __LINE__, "Invalid or unspecified rating.")
		}
	}
}else{
	FAIL(1, __LINE__, "One or more arguments are required.")
}

if(! -x "/usr/bin/tput"){
	FAIL(1, __LINE__, "Dependency '/usr/bin/tput' not met.")
}

if(!(-f $DATABASE && -r $DATABASE) && ($UPDATE_DB eq "False")){
	FAIL(1, __LINE__, "Database file missing or inaccessible.")
}elsif((-z $DATABASE) && ($UPDATE_DB ne "True")){
	FAIL(1, __LINE__, "Database file is empty.")
}elsif($UPDATE_DB eq "True"){
	use LWP::UserAgent;

	open(my $FH, '>', $DATABASE);

	my $UA = LWP::UserAgent->new();
	$UA->agent('Mozilla/5.0');
	my $BUFFER = $UA->get($DB_SITE)->decoded_content;
	print($FH $BUFFER);

	close($FH);

	exit 0
}

$Text::Wrap::columns = `/usr/bin/tput cols`;

open(my $FH, '<', $DATABASE);

my $STAR1_COUNT = 0;
my $STAR2_COUNT = 0;
my $STAR3_COUNT = 0;
my $STAR4_COUNT = 0;
my $STAR5_COUNT = 0;
my $TTL_COUNT = 0;
my $COUNT = 0;

while(<$FH>){
	my @LINE = split("~~~", $_);

	my $PACK = $LINE[0];
	my $RATE = $LINE[3];
	my $SAID = $LINE[4];
	my $USER = $LINE[2];

	if($PACK eq $ARGV[0]){
		$TTL_COUNT += 1;

		my @DATA = ($RATE, $SAID, $USER);
		if($DATA[0] == 1){$STAR1_COUNT += 1}
		if($DATA[0] == 2){$STAR2_COUNT += 1}
		if($DATA[0] == 3){$STAR3_COUNT += 1}
		if($DATA[0] == 4){$STAR4_COUNT += 1}
		if($DATA[0] == 5){$STAR5_COUNT += 1}

		if($DATA[0] == $ARGV[1]){
			$COUNT++;

			sub SHOW{
				printf(
					"%d/5 ('%s')\n $_[0]\n%s $_[0]\n",
					$_[3], $_[4],
					wrap(" $_[1] ", " $_[1] ", $_[2])
				)
			}

			if($BORING eq "True"){
				SHOW(" ", " ", $DATA[1], $DATA[0], $DATA[2])
			}else{
				SHOW("+", "|", $DATA[1], $DATA[0], $DATA[2])
			}
		}
	}
}

close($FH);

if($SHOW_STATS eq "True"){
	sub SHOW2{
		my $BUF = qq{
			 $_[1]$_[2]
			 $_[0] Reviews:     $COUNT/$TTL_COUNT
			 $_[0]
			 $_[0] Total 5/5:   $STAR5_COUNT
			 $_[0] Total 4/5:   $STAR4_COUNT
			 $_[0] Total 3/5:   $STAR3_COUNT
			 $_[0] Total 2/5:   $STAR2_COUNT
			 $_[0] Total 1/5:   $STAR1_COUNT
			 $_[1]$_[2]
		};

		print(split("\t", $BUF))
	}

	$BORING ne "True" ? SHOW2("|", "+", ">") : SHOW2(" ", " ", " ")
}
