#!/usr/bin/env perl

#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/apt-undo-install
# Started On        - Tue 23 Apr 18:46:07 BST 2019
# Last Change       - Sat 14 Dec 18:46:43 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# This program was written with Perl version v5.22.1
#
# NOTE: You may need to install the 'libanyevent-i3-perl' package.
#----------------------------------------------------------------------------------

use v5.22.1;
use strict;
use warnings;
use autodie;
use File::Basename 'basename';
use TFL; # <-- libtfl-perl (>= 2019-05-07)
use AptPkg::Cache; # <-- libapt-pkg-perl (>= 0.1.29build7)

no warnings 'uninitialized';

my $CurVer = "2019-12-14";
my $Progrm = basename($0);

my $Domain = 'https://github.com';

sub Usage{
	my $Help = qq{            @{[uc($Progrm)]} ($CurVer)
		            Written by terminalforlife <terminalforlife\@yahoo.com>

		            A Perl solution to undo recent APT installations.

		SYNTAX:     $Progrm [OPTS]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --quiet|-q              - Pass this flag over to apt-get.
		            --count|-c N            - Execute this N many of install undos. Will
		                                      work in reverse, from the latest to oldest.
		            --output-only:F         - Only show package name(s), if installed; -
		                                      don't uninstall. Where F is either :col, -
		                                      :list, or :desc, to choose how you'd like the
		                                      list formatted.
		            --logfile|-l FILE       - Use FILE instead of the default logfile.
		                                      But ensure it's the standard log formatting.
		                                      This will not be checked, so be careful!
		            --view                  - View the contents of the APT logfile.
		            --date|-d YYYY-MM-DD    - Specify the logged date to work with.
		            --time|-t HH:MM:SS      - Specify the logged date to work with.
		            --simulate|-s           - Use the 'simulate' option from apt-get.
		            --autoremove            - Use the 'autoremove' option from apt-get.
		            --purge                 - Use the 'purge' option from apt-get.
		            --assume-yes|-y         - Use the 'yes' option from apt-get.
		            --assume-no             - Use the 'no' option from apt-get. Takes
		                                      precedence over the 'yes' option.

		NOTE:       The standard alternative apt-get long-format flags for some of the
		            options listed above are also available with $Progrm.

		            The --date and --time flags may fail to work with your APT logfile if
		            you're using non-standard localisation settings for an English-speaker.
		            These flags should also not be used with the --count flag.

		EXAMPLE:    $Progrm --purge --autoremove -c 2
		            $Progrm --logfile /tmp/history.log --output-only:list
		            $Progrm --date 2017-00-00 --time 20:00:00 --simulate

		FILE:       /var/log/apt/history.log
	};

	print($Help =~ tr/\t//dr)
}

my $VerURL = "$Domain/terminalforlife/$Progrm/raw/master/version";
my $AptLogFile = '/var/log/apt/history.log';
my $ViewLog = 0;
my $TimesExec = 1;
my $ToRoot = 1;
my $OutOnly = 0;

my (
	$OutputFormat, $ToAssume, $ToPurge, $ToAutoRemove,
	$BeQuiet, $ToSim, $FiltaDate, $FiltaTime
);

while($ARGV[0]){
	if($ARGV[0] =~ /^(--help|-h|-\?)$/){
		Usage(); exit(0)
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print($CurVer . "\n"); exit(0)
	}elsif($ARGV[0] =~ /^(--quiet|-q)$/){
		$BeQuiet = "--quiet"
	}elsif($ARGV[0] =~ /^(--logfile|-l)$/){
		shift(@ARGV);

		TFL::FAIL(1, __LINE__, "Option '--logfile|-l' requires a file.")
			if length($ARGV[0]) == 0;

		TFL::FAIL(1, __LINE__, "Unable to find or read APT's logfile.")
			unless -f $ARGV[0] and -r $ARGV[0];

		$AptLogFile = $ARGV[0]
	}elsif($ARGV[0] =~ /^--autoremove$/){
		$ToAutoRemove = "--autoremove"
	}elsif($ARGV[0] =~ /^--view$/){
		$ViewLog = 1
	}elsif($ARGV[0] =~ /^--assume-yes$/){
		$ToAssume = "--assume-yes"
	}elsif($ARGV[0] =~ /^--assume-no$/){
		$ToAssume = "--assume-no"
	}elsif($ARGV[0] =~ /^--purge$/){
		$ToPurge = "--purge"
	}elsif($ARGV[0] =~ /^(--date|-d)$/){
		shift(@ARGV);

		TFL::FAIL(1, __LINE__, "Invalid date specified.")
			if not $ARGV[0] =~ /^[0-9]+-[0-9]+-[0-9]+$/;

		$FiltaDate = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--time|-t)$/){
		shift(@ARGV);

		TFL::FAIL(1, __LINE__, "Invalid time specified.")
			if not $ARGV[0] =~ /^[0-9]+:[0-9]+:[0-9]+$/;

		$FiltaTime = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--count|-c)$/){
		shift(@ARGV);

		TFL::FAIL(1, __LINE__, "Invalid count specified.")
			if not $ARGV[0] =~ /^[0-9]+$/;

		$TimesExec = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--simulate|-s)$/){
		$ToSim = "--simulate"; $ToRoot = 0
	}elsif($ARGV[0] =~ /^--output-only:(desc|list|col)/){
		$OutOnly = 1;
		$ToRoot = 0; # <-- Already the default, but just in-case.
		$OutputFormat = substr($ARGV[0], 14)
	}else{
		TFL::FAIL(1, __LINE__, "Incorrect argument(s) given")
	}

	shift(@ARGV)
}

if($ViewLog){
	system(qq{less "$AptLogFile"});
	exit(0)
}

# $> is Perl's builtin variable assigned to the value of the user's EUID.
if($ToRoot && $> != 0){
	TFL::FAIL(1, __LINE__, "Root access is required.")
}

open(my $FH, '<', $AptLogFile);
my @Data = <$FH>;
close($FH);

# This loop is an improvement over the shell version; it's more concise.
my $InstallWC = 0;
my @InstallOnlyLines;
foreach (@Data){
	# Put only the install lines into the above array.
	if($_ =~ /^Install:/){
		push(@InstallOnlyLines, $_);
		$InstallWC += 1
	}

	shift(@_)
}

if($TimesExec > $InstallWC){
	TFL::FAIL(1, __LINE__, "Cannot undo greater than the available $InstallWC time(s).")
}

my @InstalledPKGs;
if($FiltaDate && $FiltaTime){
	my $SeenDate = "False";
	my $Count = 0;
	my @CurLine;

	foreach my $Buffer (@Data){
		next if length($Buffer) <= 1;
		@CurLine = split(" ", $Buffer);

		if($CurLine[0] eq "Start-Date:"){
			if($CurLine[1] eq $FiltaDate && $CurLine[2] eq $FiltaTime){
				$SeenDate = "True";
				$Count = 0
			}
		}

		if($SeenDate eq "True"){$Count += 1}

		#TODO: See if this $Count default set is even needed.
		$Count //= 5; # Mimics the shell: ${Count:-5}
		if($Count == 4 && $CurLine[0] eq "Install:"){
			foreach my $Word (@CurLine){
				unless($Word =~ /^(Install:|.*[\(\)].*)/){
					push(@InstalledPKGs, $Word);
				}
			}

			last
		}
	}

	if(not @InstalledPKGs){
		TFL::FAIL(1, __LINE__, "Invalid --time and/or --date specified.")
	}
}elsif(not($FiltaDate && $FiltaTime) and ($FiltaDate || $FiltaTime)){
	TFL::FAIL(1, __LINE__, "Flags --date and --time must be used together.")
}else{
	my $DesiredIndices = $InstallWC - $TimesExec;
	foreach my $Index ($DesiredIndices..$InstallWC){
		if($InstallOnlyLines[$Index]){ # <-- Avoids empty line errors.
			foreach my $Word (split(" ", $InstallOnlyLines[$Index])){
				if($Word !~ /^(Install:|.*[\)\(].*|automatic)$/){
					push(@InstalledPKGs, $Word)
				}
			}
		}
	}
}

if(not $OutOnly){
	system(
		qq{/usr/bin/apt-get $BeQuiet $ToSim $ToAssume remove } .
		qq{$ToPurge $ToAutoRemove -o Dpkg::Progress-Fancy=true -o } .
		qq{Dpkg::Progress=true @InstalledPKGs}
	)
}else{
	if($OutputFormat =~ /^desc$/){
		my $Cache = AptPkg::Cache->new();
		my $Descs = $Cache->packages("DescriptionList");
		foreach(@InstalledPKGs){
			my $Gets = $Cache->get("$_");
			my $Name = $Gets->{"FullName"};
			my $Desc = $Descs->lookup("$_")->{"ShortDesc"};
			printf("%s - %s\n", $Name, $Desc)
		}
	}elsif($OutputFormat =~ /^col$/){
		system(qq{printf "%s\n" @InstalledPKGs | /usr/bin/column})
	}elsif($OutputFormat =~ /^list$/){
		foreach(@InstalledPKGs){
			print("$_\n")
		}
	}
}
