#!/usr/bin/env perl
#cito M=755 O=0 G=0 T=/usr/bin/lspkg
#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/lspkg
# Started On        - Mon 23 Dec 15:26:46 GMT 2019
# Last Change       - Thu 26 Dec 20:26:19 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# A Perl rewrite of the shell project 'lspkg' and 'lspkg-set' written by TFL/LL.
#----------------------------------------------------------------------------------

#TODO: Add search feature, to allow the user to filter in/out package names.
#TODO: Allow the user to also search through the short descriptions for something.
#TODO: Distinguish and allow choice between case-(in)sensitive searches.
#TODO: Add ability to display things like the currenty installed package version.

use strict;
use warnings;
use autodie;
use File::Basename 'basename';
use TFL; # <-- libtfl-perl (>= 2019-05-18)
use List::MoreUtils 'uniq';

no warnings 'uninitialized';

my $CurVer = "2019-12-26";
my $Progrm = basename($0);

my $StatusFile = '/var/lib/dpkg/status';

sub Usage{
	my $Info = qq{            @{[uc($Progrm)]} ($CurVer)
		            Written by terminalforlife (terminalforlife\@yahoo.com)

		            ...

		SYNTAX:     $Progrm [OPTS] [PKG_1 [PKG_2] ...]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --reverse|-R            - Display package names in reverse.

		FILE:       $StatusFile
	};

	print($Info =~ tr/\t//dr)
}

my $DoRev;

while(defined($ARGV[0])){
	if($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit 0
	}elsif($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit 0
	}elsif($ARGV[0] =~ '^(--reverse|-R)$'){
		$DoRev = 'true'
	}elsif($ARGV[0] =~ '^-'){
		TFL::Err(1, "Incorrect argument(s) specified")
	}else{
		last
	}

	shift(@ARGV)
}

open(my $FH, '<', $StatusFile);

my (%Packages, $LastPKG);
while (<$FH>){
	chomp(my @Arr = split(': ', $_));
	next unless scalar(@Arr) >= 2;

	if ($Arr[0] eq 'Package'){
		$LastPKG = $Arr[1];
	}elsif ($Arr[0] eq 'Status'){
		$Packages{$LastPKG}{'Status'} = $Arr[1]
	}elsif ($Arr[0] eq 'Description'){
		$Packages{$LastPKG}{'Description'} = $Arr[1]
	}
}

close($FH);

my @Data;

if ($DoRev ne 'true'){
	@Data = uniq(sort({$a cmp $b} keys(%Packages)));
}else{
	@Data = uniq(sort({$b cmp $a} keys(%Packages)));
}

printf("%s - %s\n", $_, $Packages{$_}{'Description'}) foreach @Data
