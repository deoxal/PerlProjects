#!/usr/bin/env perl

#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/git-tudu
# Started On        - Sat 14 Dec 19:42:12 GMT 2019
# Last Change       - Sun 15 Dec 20:41:00 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# Work-in-progress developer tool to get an overview of your programming todos.
#
# What to test it out for me?
#
#   1. Make sure you have the dependencies:
#
#     * perl (>= 5.22.1)
#
#     * libtfl-perl (>= 2019-12-14)
#     * libterm-readkey-perl (>= 2.33-1build1)
#     * libfile-listing-perl (>= 6.04-1)
#
#     The versions may not need to be precise; just a guideline.
#
#   2. Open a terminal, then change to the directory in which git-tudu resides.
#
#   3. Run the following command (sans dollar):
#
#     $ perl git-tudu -P /path/to/your/code
#
#   When telling me about bugs or submitting an issue on GitHub, be sure to tell me
#   your Distribution of Linux (or if on Mac, BSD, etc), Perl version (`perl -v`)
#   and whatever else you might think would be useful, like errors or odd output.
#
#   Thanks!
#----------------------------------------------------------------------------------

#TODO: This is a test.
#TODO: This is a teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeest.
#TODO: This is a test line which is too long so it needs to be dealt with the only way possible.

use v5.22.1;
use strict;
use warnings;
use autodie;
use File::Basename 'basename', 'dirname';
use TFL; # <-- libtfl-perl (>= 2019-12-14)
use File::Find; # <-- libfile-listing-perl (>= 6.04-1)
use Term::ReadKey 'GetTerminalSize'; # <-- libterm-readkey-perl (>= 2.33-1build1)

# I'll disable it when this is actually needed.
no warnings 'uninitialized';

my $CurVer = "2019-12-15";
my $Progrm = basename($0);

sub Usage{
	my $Info = qq{            @{[uc($Progrm)]} ($CurVer)
		            Written by terminalforlife <terminalforlife\@yahoo.com>

		            Get an overview of programming todos with this developer tool.

		SYNTAX:     $Progrm [OPTS] [PATTERN]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --alt-path|-P PATH      - Override prior-set path with PATH.
		            --set-path|-s PATH      - Set and save the target PATH.
		            --boring|-b             - Omit the pretty ASCII characters.

		NOTE:       Signifying the end of OPTS with '--' is supported.

		            When specifying an alternative PATH, it's possible and intended
		            that the user could provide a file, instead of a directory.

		            Where PATTERN is a REGEX string to use to filter todo entries.

		            All binary files will be ignored, as will those for which
		            needed permissions are lacking.
	};

	print($Info =~ tr/\t//dr)
}

my ($Target, $Boring);

# Tabs, whitespaces, and other characters prior to this will be ignored, except
# the one space before and after the todo string. Don't want to get confused with
# any code which happens to have this string in it. Must be one field.
my $TodoStr = '#TODO:';

# Snip the one whitespace before the todo entry.
my $TodoStrLen = length($TodoStr) + 1;

my $MainDir = "$ENV{HOME}/.config/$Progrm";
mkdir($MainDir) unless -d $MainDir;

my $TargetFile = "$MainDir/target";
my $ExcludeFile = "$MainDir/exclude";

while(defined($ARGV[0])){
	#TODO: This is an indented test.
	if($ARGV[0] =~ /^--$/){
		last # <-- End of option processing.
	}elsif($ARGV[0] =~ /^(--help|-h|-\?)$/){
		Usage(1); exit 0
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print("$CurVer\n"); exit 0
	}elsif($ARGV[0] =~ /^(--alt-path|-P)$/){
		shift(@ARGV);

		TFL::Err(1, "Option '--alt-path|-P' requires a PATH.")
			unless length($ARGV[0]) > 0;

		$Target = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--set-path|-s)$/){
		shift(@ARGV);

		TFL::Err(1, "Option '--set-path|-s' requires a PATH.")
			unless length($ARGV[0]) > 0;

		open(my $FH, '>', $TargetFile);
		printf($FH "%s\n", $ARGV[0]);
		close($FH);

		exit(0)
	}elsif($ARGV[0] =~ /^(--boring|-b)$/){
		$Boring = 'true'
	}elsif($ARGV[0] =~ /^-/){
		TFL::Err(1, "Incorrect option(s) -- see: $Progrm -h")
	}else{
		last
	}

	shift(@ARGV)
}

TFL::Err(1, "Too many arguments -- see: $Progrm -h") if scalar(@ARGV) > 1;

# If not overridden above, try user's pre-set.
if (length($Target) == 0 and -f -r -T $TargetFile){
	open(my $FH, '<', $TargetFile);
	chomp($Target = <$FH>);
	close($FH);

	TFL::Err(1, "Reading file '~/.config/$Progrm/target' failed.")
		if length($Target) == 0
}

sub Display{ # Usage: Display [MAX_COLS] [C_END] [C_MID] [C_BUL] [C_OFL]
	our $TermCols = $_[0];

	# Sets up possible future expansion to allow user-provided choices.
	our $CharEnd = $_[1]; # <-- Top and bottom (ends) of divider.
	our $CharMid = $_[2]; # <-- Middle of divider, before todo entries.
	our $CharBul = $_[3]; # <-- The bullet point character.
	our $CharOfl = $_[4]; # <-- The column overflow character.

	# Read file ($_[0]) then output pretty and column-mindful list of todo entries.
	# For now, we're dealing with one-liners only. Eventually, I'd like to see
	# multi-line todo entries, but that will require some faffing about.
	sub GetTodo{
		open(my $FH, '<', $_[0]); #TODO: Test on-line, after code.
		my $FileShown = $_[0] =~ s/$ENV{HOME}/\~/dr;

		my (@TodoList, $Valid);
		while (<$FH>){
			undef($Valid);
			chomp($_);

			# Skip empty lines, or lines with only trailing whitespaces, tabs, etc.
			next if $_ =~ /(^$|^#+ |^[[:space:]]+$)/;

			# Check each field in line for the todo string.
			$Valid = 'true' if grep(m/^$TodoStr$/, split(' ', $_));

			if ($Valid eq 'true'){
				my $Todo = $_ =~ s/^.*$TodoStr //dr;
				my $TodoLen = length($Todo);

				# If entry is too long, snip it with the overflow character.
				$Todo = substr($Todo, 0, $TermCols - ($TodoLen + 12)) . $CharOfl
					if $TodoLen > $TermCols - 7; # <-- Bit squishy; dunno why.

				# Maximum line supported is 9,999,999. If an override feature is
				# requested, I'll probably get to adding that. If you have one file
				# of anything like that number, you probably should split it up.
				push(@TodoList, sprintf(" %7d %s %s", $., $CharMid, $Todo))
			}
		}

		close($FH);

		# Don't show anything if no todos were found.
		return(1) unless scalar(@TodoList) > 0;

		# To ensure the filenames don't flow over the coloumn limit.
		my $DirName = dirname($FileShown) =~ s/.*\//...\//dr . '/';
		$FileShown = $DirName . basename($FileShown)
			if length($FileShown) > $TermCols - 2;

		printf(" %s %s\n%10s\n", $CharBul, $FileShown, $CharEnd);
		printf("%s\n", $_) foreach @TodoList;
		printf("%10s\n", $CharEnd)
	}

	if (-d $Target){
		TFL::Err(1, 'Directory inaccessible.') unless -r -x $Target;

		our @FileArr;

		sub Conditions{
			my $Name = $File::Find::name;

			# Must be a readable non-binary file.
			return(1) unless -f -r -T $Name;

			my @SplitName = split('/', $Name);
			my $SplitNameLen = scalar(@SplitName);

			foreach (@SplitName){
				return(1) if $_ eq '.git'
			}

			push(@FileArr, $Name)
		}

		# Recursive search for files in `Target` per `Conditions()`.
		find(\&Conditions, $Target);

		foreach (@FileArr){GetTodo($_)}
	}elsif (-f $Target){
		TFL::Err(1, 'File unreadable.') unless -r $Target;
		TFL::Err(1, 'File is binary.') if -r -B $Target;

		GetTodo($Target)
	}
}

if ($Boring ne 'true'){
	Display(@{[GetTerminalSize()]}[0], '+', '|', '*', '/')
}else{
	Display(@{[GetTerminalSize()]}[0], ' ', ' ', ' ', ' ')
}
