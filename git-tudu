#!/usr/bin/env perl

#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/git-tudu
# Started On        - Sat 14 Dec 19:42:12 GMT 2019
# Last Change       - Sun 15 Dec 02:55:32 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# Work-in-progress developer tool to get an overview of your programming todos.
#
# What to test it out for me?
#
#   1. Make sure you have the dependencies:
#
#     * perl (>= 5.22.1)
#
#     * libtfl-perl (>= 2019-12-14)
#     * libterm-readkey-perl (>= 2.33-1build1)
#     * libfile-listing-perl (>= 6.04-1)
#
#     The versions may not need to be precise; just a guideline.
#
#   2. Open a terminal, then change to the directory in which git-tudu resides.
#
#   3. Run the following command (sans dollar):
#
#     $ perl git-tudu
#
#   Nothing will show, since it's temporarily set to my location, so either edit
#   the code yourself, or create a file with only the path to your GitHub
#   directory.
#
#     $ mkdir -p ~/.config/git-tudu
#     $ printf '%s\n' > ~/.config/git-tudu/git-dir
#
#   Now try git-tudu again.
#
#   When telling me about bugs or submitting an issue on GitHub, be sure to tell me
#   your Distribution of Linux (or if on Mac, BSD, etc), Perl version (`perl -v`)
#   and whatever else you might think would be useful, like errors or odd output.
#
#   Thanks!
#----------------------------------------------------------------------------------

#TODO: This is a test.
#TODO: This is a test.ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
#TODO: This is a test line which is too long so it needs to be dealt with the only way possible.

use v5.22.1;
use strict;
use warnings;
use autodie;
use File::Basename 'basename';
use TFL; # <-- libtfl-perl (>= 2019-12-14)
use File::Find; # <-- libfile-listing-perl (>= 6.04-1)
use Term::ReadKey 'GetTerminalSize'; # <-- libterm-readkey-perl (>= 2.33-1build1)

# I'll disable it when this is actually needed.
no warnings 'uninitialized';

my $CurVer = "2019-12-15";
my $Progrm = basename($0);

sub Usage{
	my $Info = qq{            @{[uc($Progrm)]} ($CurVer)
		            Written by terminalforlife <terminalforlife\@yahoo.com>

		            Get an overview of programming todos with this developer tool.

		SYNTAX:     $Progrm [OPTS] [PATTERN]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --alt-path|-P PATH      - Override prior-set path with PATH.

		NOTE:       Signifying the end of OPTS with '--' is supported.

		            When specifying an alternative PATH, it's possible and intended
		            that the user could provide a file, instead of a directory.

		            Where PATTERN is a REGEX string to use to filter todo entries.

		            All binary files will be ignored, as will those for which
		            needed permissions are lacking.

	};

	print($Info =~ tr/\t//dr)
}

my $LookHere;

while(defined($ARGV[0])){
	if($ARGV[0] =~ /^--$/){
		last # <-- End of option processing.
	}elsif($ARGV[0] =~ /^(--help|-h|-\?)$/){
		Usage(1); exit 0
	}elsif($ARGV[0] =~ /^(--version|-v)$/){
		print("$CurVer\n"); exit 0
	}elsif($ARGV[0] =~ /^(--alt-path|-P)$/){
		shift(@ARGV);

		TFL::Err(1, "Option '--alt-path|-P' requires a PATH.")
			unless length($ARGV[0]) > 0;

		$LookHere = $ARGV[0]
	}elsif($ARGV[0] =~ /^-/){
		TFL::Err(1, "Incorrect argument(s) specified")
	}else{
		last
	}

	shift(@ARGV)
}

if (scalar(@ARGV) == 0){
	$LookHere = "$ENV{HOME}/GitHub/terminalforlife/Personal"
}else{
	$LookHere = $ARGV[0]
}

TFL::Err(1, 'One alternative PATH is valid.') if scalar(@ARGV) > 1;

my $MainDir = "$ENV{HOME}/.config/git-tudu";
my $ExcludeFile = "$MainDir/exclude";
my $GitDirFile = "$MainDir/git-dir";

# Tabs, whitespaces, and other characters prior to this will be ignored, except
# the one space before and after the todo string. Don't want to get confused with
# any code which happens to have this string in it. Must be one field.
my $TodoStr = '#TODO:';

# Snip the one whitespace before the text.
my $TodoStrLen = length($TodoStr) + 1;

sub ReadFile{
	return(1) unless -f -r $_[0];

	open(my $FH, '<', $_[0]);
	chomp(my @FileData = <$FH>);
	close($FH);

	return(@FileData)
}

sub Display{ # Usage: Display [MAX_COLS] [C_END] [C_MID] [C_BUL] [C_OFL]
	our $TermCols = $_[0];

	# Sets up possible future expansion to allow user-provided choices.
	our $CharEnd = $_[1]; # <-- Top and bottom (ends) of divider.
	our $CharMid = $_[2]; # <-- Middle of divider, before todo entries.
	our $CharBul = $_[3]; # <-- The bullet point character.
	our $CharOfl = $_[4]; # <-- The column overflow character.

	# Read file ($_[0]) then output pretty and column-mindful list of todo entries.
	# For now, we're dealing with one-liners only. Eventually, I'd like to see
	# multi-line todo entries, but that will require some faffing about.
	sub GetTodo{
		my $File;
		if (scalar(@ARGV) == 0){
			$File = $_[0] =~ s/$LookHere\///dr;
		}else{
			$File = basename($_[0]);
		}

		my @TodoList;
		my $LineCount = 1;
		foreach (ReadFile($_[0])){
			my @LineArr = split(' ', $_);

			if ($LineArr[0] eq $TodoStr){
				my $OmitLeadSpace = $_ =~ s/^[[:space:]]+//dr;
				my $Todo = substr($OmitLeadSpace, $TodoStrLen, length($_));
				my $TodoLen = length($Todo);

				# If entry is too long, snip it with three periods suffixed.
				$Todo = substr($Todo, 0, $TodoLen - 7) . $CharOfl
					if $TodoLen > $TermCols - 7; # <-- Bit squishy; dunno why.

				# Maximum line supported is 9,999,999. If an override feature is
				# requested, I'll probably get to adding that. If you have one file
				# of anything like that number, you probably should split it up.
				push(@TodoList, sprintf(" %7d %s %s", $LineCount, $CharMid, $Todo))
			}

			$LineCount++
		}

		# Don't show anything if no todos were found.
		return(1) unless scalar(@TodoList) > 0;

		printf(" %s '%s'\n%10s\n", $CharBul, $File, $CharEnd);
		printf("%s\n", $_) foreach @TodoList;
		printf("%10s\n", $CharEnd)
	}

	if (-d $LookHere){
		TFL::Err(1, 'Directory inaccessible.') unless -r -x $LookHere;

		our @FileArr;

		sub Conditions{
			# Must be a readable non-binary file.
			return(1) unless -f -r -T $_;

			my @SplitName = split('/', $File::Find::name);
			my $SplitNameLen = scalar(@SplitName);

			foreach (@SplitName){
				return(1) if $_ eq '.git'
			}

			push(@FileArr, $File::Find::name)
		}

		# Recursive search for files in `LookHere` per `Conditions()`.
		find(\&Conditions, glob("$LookHere/*"));

		foreach (@FileArr){
			GetTodo($_)
		}
	}elsif (-f $LookHere){
		TFL::Err(1, 'File unreadable.') unless -r $LookHere;
		TFL::Err(1, 'File is binary.') if -r -B $LookHere;

		GetTodo($LookHere)
	}
}

Display(@{[GetTerminalSize()]}[0], '+', '|', '*', '/')
