#!/usr/bin/env perl

#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/git-tudu
# Started On        - Sat 14 Dec 19:42:12 GMT 2019
# Last Change       - Mon 16 Dec 02:36:42 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

use v5.22.1;
use strict;
use warnings;
use autodie;
use File::Basename 'basename', 'dirname';
use TFL; # <-- libtfl-perl (>= 2019-12-14)
use File::Find; # <-- libfile-listing-perl (>= 6.04-1)
use List::MoreUtils; # <-- liblist-moreutils-perl (>= 0.413-1build1)
use Term::ReadKey 'GetTerminalSize'; # <-- libterm-readkey-perl (>= 2.33-1build1)
use Term::ANSIColor 'color', 'colorvalid';

# I'll disable it when this is actually needed.
no warnings 'uninitialized';

my $CurVer = "2019-12-16";
my $Progrm = basename($0);

sub Usage{
	my $Info = qq{            @{[uc($Progrm)]} ($CurVer)
		            Written by terminalforlife <terminalforlife\@yahoo.com>

		            Get an overview of programming todos with this developer tool.

		SYNTAX:     $Progrm [OPTS] [REGEX]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --ignore-case|-i        - Case-insensitive search for REGEX.
		            --alt-path|-P PATH      - Override value in config with PATH.
		            --config PATH           - Override default file with PATH.

		NOTE:       Signifying the end of OPTS with '--' is supported.

		            When specifying an alternative PATH, it's possible and intended
		            that the user could provide a file, instead of a directory.

		            Where REGEX is a REGEX string to use to filter todo entries.

		            All binary files will be ignored, as will those for which
		            needed permissions are lacking.

		CONFIG:     A user configuration file (see below) will be generated when
		            the program is executed without such a file existing.

		            The default 'Target' is the current working directory, and the
		            default TODO string is '#TODO:', where '#' indicates a comment.

		FILE:       ~/.config/git-tudu/config
	};

	print($Info =~ tr/\t//dr)
}

my ($Target, $Pretty, $DoCase, %CHash);

# Tabs, whitespaces, and other characters prior to this will be ignored, except
# the one space before and after the todo string. Don't want to get confused with
# any code which happens to have this string in it. Must be one field.
my $TodoStr = '#TODO:';

# Snip the one whitespace before the todo entry.
my $TodoStrLen = length($TodoStr) + 1;

my $MainDir = "$ENV{HOME}/.config/$Progrm";
mkdir($MainDir) unless -d $MainDir;

my $TargetFile = "$MainDir/target";
my $ExcludeFile = "$MainDir/exclude";
my $ConfigFile = "$MainDir/config";

my @ValidKeys = (
	'TodoBody', 'Bullet', 'EOL', 'MidChar', 'Target',
	'EndChar', 'FileName', 'Numbers', 'Pretty', 'TodoStr'
);

while(defined($ARGV[0])){
	if($ARGV[0] =~ /^--$/){
		last # <-- End of option processing.
	}elsif($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(1); exit 0
	}elsif($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit 0
	}elsif($ARGV[0] =~ '^(--ignore-case|-i)$'){
		$DoCase = 'i'
	}elsif($ARGV[0] =~ '^(--alt-path|-P)$'){
		shift(@ARGV);

		TFL::Err(1, "Option '--alt-path|-P' requires a PATH.")
			unless length($ARGV[0]) > 0;

		$Target = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift(@ARGV);

		TFL::Err(1, "Option '--config|-c' requires a PATH.")
			unless length($ARGV[0]) > 0;

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^-'){
		TFL::Err(1, "Incorrect option(s) -- see: $Progrm -h")
	}else{
		last
	}

	shift(@ARGV)
}

if (scalar(@ARGV) > 1){
	TFL::Err(1, "Too many arguments -- see: $Progrm -h")
}elsif ($DoCase eq 'i' and scalar(@ARGV) == 0){
	TFL::Err(1, "Option '--ignore-case|-i' used, but no REGEX provided.")
}

# If not overridden above, try user's pre-set.
if (length($Target) == 0 and -f -r -T $TargetFile){
	open(my $FH, '<', $TargetFile);
	chomp($Target = <$FH>);
	close($FH);

	TFL::Err(1, "Reading file '~/.config/$Progrm/target' failed.")
		if length($Target) == 0
}

# Read the `config` file, if found, then populate the config hash.
if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);
	my @Data = <$FH>;
	close($FH);

	foreach (@Data){
		next if length($_) <= 1 or $_ =~ '^#';
		chomp(my ($Key, $Value) = split('=', $_));

		# Iterate over ckeys to check they're valid.
		my $IsFound;
		foreach (@ValidKeys){
			if ($Key eq $_){
				$IsFound = 'true';
				last
			}
		}

		if ($IsFound eq 'true'){
			if ($Key eq 'Pretty'){
				$Pretty = $Value
			}elsif ($Key eq 'Target'){
				$Target = $Value
			}elsif ($Key eq 'TodoStr'){
				$TodoStr = $Value
			}else{
				TFL::Err(1, "Invalid color '$Value' detected.")
					unless colorvalid($Value);
			}

			$CHash{$Key} = $Value =~ tr/['"]//dr
		}else{
			TFL::Err(1, "Invalid key '$Key' detected.")
		}
	}
}else{
	# Generate the default config.
	open(my $FH, '>', $ConfigFile);

	my $Contents = qq{# User configuration file for `git-tudu`

		Target=./
		TodoStr=#TODO:
		Pretty=false

		Bullet=bright_white
		EOL=bright_black
		EndChar=bright_black
		FileName=bright_black
		MidChar=bright_black
		Numbers=red
		TodoBody=bright_white};

	printf($FH "%s\n", $Contents =~ tr/\t//dr);

	close($FH);
	printf("File '~/.config/git-tudu/config' generated -- please restart.\n");
	exit(0)
}

sub Display{ # Usage: Display [MAX_COLS] [C_END] [C_MID] [C_BUL] [C_OFL]
	our $TermCols = $_[0];

	# Sets up possible future expansion to allow user-provided choices.
	our $CharEnd = $_[1]; # <-- Top and bottom (ends) of divider.
	our $CharMid = $_[2]; # <-- Middle of divider, before todo entries.
	our $CharBul = $_[3]; # <-- The bullet point character.
	our $CharOfl = $_[4]; # <-- The column overflow character.

	# Read file ($_[0]) then output pretty and column-mindful list of todo entries.
	# For now, we're dealing with one-liners only. Eventually, I'd like to see
	# multi-line todo entries, but that will require some faffing about.
	sub GetTodo{
		open(my $FH, '<', $_[0]);
		my $FileShown = $_[0] =~ s/$ENV{HOME}/\~/dr;

		my (@TodoList, $Valid);
		while (<$FH>){
			undef($Valid);
			chomp($_);

			# Skip empty lines, or lines with only trailing whitespaces, tabs, etc.
			next if $_ =~ /(^$|^#+ |^[[:space:]]+$)/;

			# Check each field in line for the todo string.
			$Valid = 'true' if grep(m/^$TodoStr$/, split(' ', $_));

			if ($Valid eq 'true'){
				my $Todo = $_ =~ s/^.*$TodoStr //dr;
				my $TodoLen = length($Todo);

				# If entry is too long, snip it with the overflow character.
				if ($TodoLen > $TermCols - 10){
					$Todo = substr($Todo, 0, $TermCols - ($TodoLen + 12)) .
						color($CHash{EOL}) . $CharOfl . color('reset')
				}

				# Look for user-provided REGEX in line, if one is given.
				if (length($ARGV[0]) > 0){
					if ($DoCase eq 'i'){
						next unless grep(m/$ARGV[0]/i, $Todo)
					}else{
						next unless grep(m/$ARGV[0]/, $Todo)
					}
				}

				# Maximum line supported is 9,999,999. If an override feature is
				# requested, I'll probably get to adding that. If you have one file
				# of anything like that number, you probably should split it up.
				push(
					@TodoList,
					sprintf(
						color($CHash{Numbers}) . " %7d " . color('reset') .
						color($CHash{MidChar}) . "%s" . color('reset') .
						color($CHash{TodoBody}) . " %s" . color('reset'),
						$., $CharMid, $Todo
					)
				)
			}
		}

		close($FH);

		# Don't show anything if no todos were found.
		return(1) unless scalar(@TodoList) > 0;

		# To ensure the filenames don't flow over the coloumn limit.
		my $DirName = dirname($FileShown) =~ s/.*\//...\//dr . '/';
		$FileShown = $DirName . basename($FileShown)
			if length($FileShown) > $TermCols - 2;

		printf(
			color($CHash{Bullet}) . " %s " . color('reset') .
			color($CHash{FileName}) . "%s" . color('reset') .
			color($CHash{EndChar}) . "\n%10s\n" . color('reset'),
			$CharBul, ${FileShown}, $CharEnd
		);

		printf(color($CHash{MidChar}) . "%s\n" . color('reset'), $_) foreach @TodoList;
		printf(color($CHash{EndChar}) . "%10s\n" . color('reset'), $CharEnd)
	}

	if (-d $Target){
		TFL::Err(1, 'Directory inaccessible.') unless -r -x $Target;

		our @FileArr;

		sub Conditions{
			my $Name = $File::Find::name;

			# Must be a readable non-binary file.
			return(1) unless -f -r -T $Name;

			my @SplitName = split('/', $Name);
			my $SplitNameLen = scalar(@SplitName);

			foreach (@SplitName){
				return(1) if $_ eq '.git'
			}

			push(@FileArr, $Name)
		}

		# Recursive search for files in `Target` per `Conditions()`.
		find(\&Conditions, $Target);

		foreach (@FileArr){GetTodo($_)}
	}elsif (-f $Target){
		TFL::Err(1, 'File unreadable.') unless -r $Target;
		TFL::Err(1, 'File is binary.') if -r -B $Target;

		GetTodo($Target)
	}
}

if ($Pretty eq 'true'){
	Display(@{[GetTerminalSize()]}[0], '+', '|', '*', '#')
}else{
	Display(@{[GetTerminalSize()]}[0], ' ', ' ', ' ', '#')
}
