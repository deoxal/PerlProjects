#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/gitsap
#----------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/gitsap
# Started On        - Mon  6 Jan 23:46:07 GMT 2020
# Last Change       - Tue 21 Jan 15:53:52 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------
# This project is based on a script I wrote in shell (Bash) called `gitsa` which
# did the same thing but on a simpler and slower scale.
#
# Dependencies:
#
#   libfile-listing-perl (>= 6.04-1)
#   libgit-repository-perl (>= 1.317-1)
#   libnumber-bytes-human-perl (>= 0.09-1)
#   libtfl-perl (>= 2020-01-08)
#----------------------------------------------------------------------------------

#TODO: The `Target` fails if the user provides just `/`.

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean';

no warnings 'uninitialized';

my $CurVer = "2020-01-21";

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Display an elegant overview of your git repositories.

		SYNTAX:     $TFL::PROGNAME [OPTS] [REGEX]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --ignore-case|-i        - Case-insensitive search for REGEX.
		            --alt-path|-P PATH      - Override value in config with PATH.
		            --config PATH           - Override default file with PATH.
		            --force-reset           - Force regeneration of user's config.
		            --parseable             - Parseable output, similar to raw.

		NOTE:       Signifying the end of OPTS with '--' is supported.

		            Where REGEX is a REGEX string to use to filter repositories by
		            the full path, relative to the 'Target' location.

		CONFIG:     A user configuration file (see below) will be generated when
		            the program is executed without such a file existing.

		            Once the 'config' file has been generated, adjust as needed.

		FILE:       ~/.config/$TFL::PROGNAME/config
	} =~ tr/\t//dr)
}

my (
	$ShowBranch, $SolidTarget, $Parseable, $Compact, $ShowSize,
	$DoCase, $Target, $ForceReset, %ColorHash, $OmitClean,
	$ShowLatest, $LatestFormat, $AbsoPath, $ANSIColors
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if($ARGV[0] =~ /^--$/){
		last # <-- End of option processing.
	}elsif ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(1); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--ignore-case|-i)$'){
		$DoCase = 'i'
	}elsif($ARGV[0] =~ '^(--alt-path|-P)$'){
		shift(@ARGV);

		FErr(1, __LINE__, "Option '--alt-path|-P' requires a PATH.")
			unless length($ARGV[0]) > 0;

		$Target = $ARGV[0] =~ s/\/$//r;
		$SolidTarget = 'true'
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift(@ARGV);

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] eq '--parseable'){
		$Parseable = 'true';
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift(@ARGV)
}

my $RegexStr = $ARGV[0] if defined($ARGV[0]);

if (scalar(@ARGV) > 1){
	FErr(1, __LINE__, "Too many arguments -- see: $TFL::PROGNAME -h")
}elsif ($DoCase eq 'i' and scalar(@ARGV) == 0){
	FErr(1, __LINE__, "Option '--ignore-case|-i' used, but no REGEX provided.")
}

my %Index = (
	'CKeys' => [
		'Color_Author',             # The author string of the latest commit.
		'Color_Date',               # The timestamp of the latest commit.
		'Color_Hash',               # The hash of the latest commit.
		'Color_Repo',               # Base name of each repository path.
		'Color_RepoDir',            # Directory name of each repository path.
		'Color_Status',             # Status string for each repository.
		'Color_Symbol'              # Symbol assigned to each category of status.
	],

	'Sets' => [
		'ANSIColors',               # ANSI-type color support for GitSAP.
		'AbsoPath',                 # Display repositories as an absolute path.
		'Compact',                  # Keep each result on one line.
		'LatestFormat',             # Format style to use for `ShowLatest`.
		'OmitClean',                # Don't display repositories which are clean.
		'Parseable',                # Raw-like data for use by scripts, etc.
		'RegexStr',                 # REGEX to filter results by repository path.
		'ShowBranch',               # Currently-active branch of each repository.
		'ShowLatest',               # Information for the most recent commit.
		'ShowSize',                 # Total disk space used by each repository.
		'Target'                    # Directory in which to look for repositories.
	],

	'Syms' => {
		'Char_Clean' => '≎',        # When a repository needs nothing done.
		'Char_Fix' => '⮂',          # When conflicts needing fixed are found.
		'Char_Initial' => '≔',      # Freshly-created repository yet to commit.
		'Char_Leads' => '∾',        # Repository leads by X amount of commits.
		'Char_New' => '≺',          # X amount of new, unstaged files were found.
		'Char_Removed' => '⊀',      # X amount of files were unexpectedly removed.
		'Char_Uncommitted' => '≍',  # Staged modifications yet to be committed.
		'Char_Unknown' => '!',      # When the status is unrecognised by `gitsap`.
		'Char_Unstaged' => '≭'      # Changes in the repository yet to be staged.
	}
);

use Term::ANSIColor 'color', 'colorvalid';

# This is the correct number of keys, for which will later be checked.
my $ValidKeysTTL = @{$Index{'Sets'}} + @{$Index{'CKeys'}} + keys(%{$Index{'Syms'}});

unlink($ConfigFile) if $ForceReset eq 'true';

if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);
	my @Data = <$FH>;
	close($FH);

	my $TTL = 0;
	foreach (@Data){
		next if length($_) <= 1 or $_ =~ '^#';
		chomp(my ($Key, $Value) = split('=', $_));

		# Tally up the total number of keys found, to check after below block.
		$TTL++;

		if ($Key eq 'Target'){
			FErr(1, __LINE__, "Key 'Target' not set -- see: $TFL::PROGNAME -h")
				if $Value eq 'NULL';

			$Target = $Value =~ s/\/$//r unless $SolidTarget eq 'true'
		}elsif ($Key eq 'RegexStr'){
			$RegexStr = $Value unless length($Value) == 0
		}elsif ($Key eq 'ShowBranch'){
			Boolean($Value);
			$ShowBranch = $Value
		}elsif ($Key eq 'ShowSize'){
			Boolean($Value);
			$ShowSize = $Value
		}elsif ($Key eq 'Parseable'){
			Boolean($Value);
			$Parseable = $Value unless $Parseable eq 'true'
		}elsif ($Key eq 'OmitClean'){
			Boolean($Value);
			$OmitClean = $Value
		}elsif ($Key eq 'ShowLatest'){
			Boolean($Value);
			$ShowLatest = $Value
		}elsif ($Key eq 'ANSIColors'){
			Boolean($Value);
			$ANSIColors = $Value
		}elsif ($Key eq 'AbsoPath'){
			Boolean($Value);
			$AbsoPath = $Value
		}elsif ($Key eq 'LatestFormat'){
			FErr(1, __LINE__, "Invalid '$Key' value detected.")
				unless $Value =~ '^(array|simple|describe)$';

			$LatestFormat = $Value
		}elsif ($Key =~ '^Color_.*'){
			FErr(1, __LINE__, "Invalid color '$Value' detected.")
				unless colorvalid($Value);

			next if $ANSIColors eq 'false';

			$ColorHash{$Key} = color($Value =~ tr/['"]//dr)
		}elsif ($Key =~ '^Char_.*'){
			unless (exists(${$Index{'Syms'}}{$Key})){
				FErr(1, __LINE__, "Invalid 'Char_*' key detected.")
			}elsif (length($Value) > 1){
				FErr(1, __LINE__, "Invalid 'Char_*' value detected.")
			}elsif (length($Value) == 0){
				next
			}

			${$Index{'Syms'}}{$Key} = $Value =~ tr/['"]//dr
		}elsif ($Key eq 'Compact'){
			Boolean($Value);
			$Compact = $Value
		}else{
			FErr(1, __LINE__, "Invalid key '$Key' detected.")
		}
	}

	FErr(1, __LINE__, 'One or more keys are missing.') if $TTL < $ValidKeysTTL;

	# This should catch rogue keys which passed by Char_* and Color_* tests.
	FErr(1, __LINE__, "One or more 'Char_*' and/or 'Color_*' keys are invalid.")
		if $TTL > $ValidKeysTTL
}else{
	open(my $FH, '>', $ConfigFile);

	print($FH qq{# User configuration file for GitSAP ($CurVer)

		# Specify the absolute path for GitSAP to use. The initial tilde and most
		# of the environment variables are available for expansion.
		Target=NULL

		# If enabled, display the repository as an absolute path.
		AbsoPath=false

		# Display the total human-readable size of each repository.
		ShowSize=false

		# Whether or not to display the repository's current branch.
		ShowBranch=false

		# If enabled, all clean repositories will be ommitted from the results.
		OmitClean=false

		# If set to a value, it will always be used as REGEX. This could be handy
		# if you want to always view certain repositories. This key, if used, will
		# override any REGEX string otherwise set.
		RegexStr=

		# Disable this to completely disable ANSI color support.
		ANSIColors=true

		# Display text in an easy-to-parse way, sans any pretty settings.
		Parseable=false

		# Display each repository's symbol, name, and status on a single line.
		Compact=true

		# If enabled and compact mode is disabled, output the full hash, author
		# string, and timestamp for the most recent commit made to the current
		# branch of each repository.
		ShowLatest=false

		# The formatting style to use for the `ShowLatest` output.
		#
		# Valid styles:
		#
		#   `array`, `describe`, `simple`
		#
		LatestFormat=describe

		# Optionally assign your own single character to each type of status. The
		# defaults will be used if these keys' values are left empty.
		Char_Clean=
		Char_Fix=
		Char_Initial=
		Char_Leads=
		Char_New=
		Char_Removed=
		Char_Uncommitted=
		Char_Unknown=
		Char_Unstaged=

		# Various color keys and their values.
		#
		# Valid colors:
		#
		#   `black`, `blue`, `cyan`, `green`, `magenta`, `red`, `white`, `yellow`
		#
		# 3 prefixes are available:
		#
		#   `bright_`, `on_`, `on_bright_`
		#
		Color_Author=white
		Color_Date=white
		Color_Hash=white
		Color_Repo=red
		Color_RepoDir=red
		Color_Status=bright_white
		Color_Symbol=bright_red
	} =~ tr/\t//dr);

	close($FH);
	printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
	exit(0)
}

# Setting this here in-case it's disabled.
my $CNorm = color('reset') if $ANSIColors eq 'true';

# Handle user-provided environment variables.
foreach (keys(%ENV)){
	$Target = $Target =~ s|\$$_|$ENV{$_}|gr if exists($ENV{$_});
}

# Handle user-provided tilde (`~`) in place of `HOME`; first `~/` only.
$Target = $Target =~ s|^~|$ENV{'HOME'}|r if $Target =~ '^~/';

FErr(1, __LINE__, "Target directory not provided.") unless length($Target) > 0;
FErr(1, __LINE__, "Target directory not found.") unless -d $Target;

use Git::Repository;

sub GetRepos{
	use Cwd;

	#TODO: Disabled until the result is achievable without the git module.
	# If we're within a repository, handle it, then bail.
	#my $Git = Git::Repository->new('work_tree' => getcwd());
	#return(($Git->run('rev-parse', '--show-toplevel'))) if $_[0] eq '.';
	#undef($Git); # <-- Free up some memory.

	# Gather an initial list of directories within 'Target'.
	my @Dirs;
	foreach (glob("$_[0]/{*,.*}")){
		next if m{/(\.\.|\.)$};
		push(@Dirs, $_) if -d -r -x;
	}

	# Iterate over each directory until `.git` is found, then skip to the next one.
	# This was initially done by `File::Find`, but there seemed to have been
	# annoying limitations, not to mention this approach seems a lot faster.
	my @FileArr;
	foreach (@Dirs){
		foreach (glob("$_/{*,.*}")){
			next if m{/(\.\.|\.)$};

			# Keep adding to the array until there's nothing left and the looping
			# comes to an end. It's akin to a while loop iterating over arguments.
			push(@Dirs, $_) if -d -r -x;

			if (-d -r -x $_ and ($_ =~ m{(?:.*/)(.*)})[0] eq '.git'){
				push(@FileArr, $_ =~ s/\/\.git$//r) and last
			}
		}
	}

	return(@FileArr)
}

my $Sym = ${$Index{'Syms'}}{'Char_Unknown'};
my $Desc = '..?';

sub SetSymDesc{
	# This just tidies up the code in the following level two `foreach`.
	($Sym, $Desc) = (${$Index{'Syms'}}{$_[0]}, $_[1])
}

my (@Results, $Result, $LastCom, $ShowPath);
foreach (GetRepos($Target)){
	# The path used for the code stuff.
	my $Path = $_;

	# Here, we set and parse the path the user will see.
	if ($AbsoPath ne 'true'){
		$ShowPath = ($Path =~ "(?:$Target/)(.*)")[0]
	}else{
		$ShowPath = $Path =~ s/$ENV{'HOME'}/~/r
	}

	# Look for user-provided REGEX in line, if one is given.
	if (length($RegexStr) > 0){
		if ($DoCase eq 'i'){
			next unless m{$RegexStr}i
		}else{
			next unless m{$RegexStr}
		}
	}

	my $Git = Git::Repository->new('work_tree' => $Path);

	if ($ShowLatest eq 'true'){
		my (@Arr, $Date, $Author, $Commit);

		foreach ($Git->run('log', '--left-right')){
			# Remove leading and trailing spaces from each index.
			@Arr = split(' ', $_ =~ s/(^[[:space:]]+|[[:space:]]+$)//r);

			# Ensures only the first section is parsed.
			last if /^$/;

			# Don't want this line, because it's inconsistent.
			next if /^Merge:/;

			if (/^commit/){
				$Commit = $Arr[2]
			}elsif (/^Author:/){
				$Author = "$Arr[1] $Arr[2]"
			}elsif (/^Date:/){
				$Date = substr(join(' ', @Arr[1..@Arr]), 0, length($Date) - 1)
			}
		}

		if ($LatestFormat eq 'array'){
			$LastCom = sprintf(
				"$ColorHash{'Color_Date'}     [\n         '%s',$CNorm" .
				"$ColorHash{'Color_Author'}\n         '%s',$CNorm" .
				"$ColorHash{'Color_Hash'}\n         '%s'\n     ]$CNorm",
				$Date, $Author, $Commit
			)
		}elsif ($LatestFormat eq 'simple'){
			$LastCom = sprintf(
				"$ColorHash{'Color_Date'}     %s$CNorm" .
				"$ColorHash{'Color_Author'}\n     %s$CNorm" .
				"$ColorHash{'Color_Hash'}\n     %s$CNorm",
				$Date, $Author, $Commit
			)
		}elsif ($LatestFormat eq 'describe'){
			$LastCom = sprintf(
				"$ColorHash{'Color_Date'}     Date    - '%s'$CNorm" .
				"$ColorHash{'Color_Author'}\n     Author  - '%s'$CNorm" .
				"$ColorHash{'Color_Hash'}\n     Hash    - '%s'$CNorm",
				$Date, $Author, $Commit
			)
		}
	}

	# Default values, in-case something goes wrong.
	my $Branch = "Unknown branch ";

	chomp(my @Status = $Git->run('status'));

	unless (scalar(@Status) > 0){
		FErr(1, __LINE__, 'Unable to gather git repository status data.')
	}elsif ($ShowBranch ne 'false'){
		FErr(1, __LINE__, "Unable to acquire branch information.")
			unless -f "$Path/.git/HEAD";

		open(my $FH, '<', "$Path/.git/HEAD");
		$Branch = (<$FH> =~ '(?:.*/)(.*)')[0];
		close($FH)
	}

	# Desired order of priority, from most (left) to least (right):
	#
	#   Uncommitted, Modified, New, Leads, Clean, Conflicts, Initial
	#
	# It's not by design that there still remains some situations which aren't
	# provided here. I've just yet to come across such a situation, in order to
	# correctly parse and write it.
	my ($ModifiedFound, $UntrackedFound, $AheadFound);
	foreach (@Status){
		chomp(my @Arr = split(' ', $_));

		# Some situations need a couple of lines from `@Status`, so the following
		# flags are used, still in order, for use in the other if statement.
		if ($Arr[0] eq 'modified:'){
			$ModifiedFound = 'true'
		}elsif ("$Arr[0]$Arr[1]" eq 'Untrackedfiles:'){
			$UntrackedFound = 'true'
		}elsif ("$Arr[0]$Arr[1]$Arr[3]" eq 'Yourbranchahead'){
			$AheadFound = 'true'
		}

		if ("$Arr[0]$Arr[1]$Arr[2]$Arr[3]" eq 'Changestobecommitted:'){
			SetSymDesc('Char_Unstaged', 'has changes to commit.') and last
		}elsif ($ModifiedFound eq 'true'){
			my @Data = $Git->run('diff', '--shortstat');

			my $FilesTTL;
			$FilesTTL = (split(' ', $_))[0] and last foreach @Data;

			SetSymDesc('Char_Uncommitted', "has $FilesTTL modified file(s).") and last
		}elsif ($UntrackedFound eq 'true'){
			my @Data = $Git->run('status', '--short');

			my $FilesTTL = 0;
			/^?? / and $FilesTTL++ foreach @Data;

			SetSymDesc('Char_New', "has $FilesTTL new file(s).") and last
		}elsif ($AheadFound eq 'true'){
			my $Leads = $Arr[scalar(@Arr) - 2];

			SetSymDesc('Char_Leads', "leads by $Leads commit(s).") and last
		}else{
			if ("$Arr[0]$Arr[1]$Arr[2]" eq 'nothingtocommit,'){
				my @CommitsRaw = $Git->run('log', '--format=oneline');
				my $Commits = scalar(@CommitsRaw);

				SetSymDesc('Char_Clean', "is $Commits commit(s) clean.") and last
			}elsif ("$Arr[0]$Arr[1]$Arr[2]" eq '(fixconflictsand'){
				SetSymDesc('Char_Fix', 'has conflict(s).') and last
			}elsif ("$Arr[0]$Arr[1]" eq 'Initialcommit'){
				SetSymDesc('Char_Initial', 'has no commits, yet.') and last
			}
		}
	}

	my $DirName = ($ShowPath =~ '(.*)(?:/.*)')[0];

	# Addresses repository displaying incorrectly if there's only one directory in
	# which repositories reside. Since `$Target` is omitted, `$DirName` would be
	# empty, in that situation, hence this workaround.
	$DirName = $DirName . '/' if length($DirName) > 0;

	my $BaseName = ($ShowPath =~ '(?:.*/)?(.*)')[0];

	if ($ShowBranch eq 'true'){
		$Desc = "Branch '$Branch' $Desc";
	}else{
		# Fixes starting word being lowercase, when the branch string is disabled.
		$Desc = ucfirst($Desc);
	}

	if ($ShowSize eq 'true'){
		use Number::Bytes::Human 'format_bytes';
		use File::Find;

		my $Bytes = 0;

		# Don't repeat hard links.
		my %INodeDone;

		find(
			sub {
				my ($INode, $Blocks) = (stat($_))[1,12];
				unless ($INodeDone{$INode} == 1){
					$Bytes += 512 * $Blocks;
					$INodeDone{$INode} = 1
				}
			},

			$Path
		);

		my $SansPeriod = substr($Desc, 0, length($Desc) - 1);
		$Desc = sprintf("%s, taking up %s.", $SansPeriod, format_bytes($Bytes))
	}

	if ($Parseable eq 'true'){
		$Result = sprintf("%s%s~~~%s", $DirName, $BaseName, $Desc)
	}elsif ($Compact eq 'true'){
		$Result = sprintf(
			"$ColorHash{'Color_Symbol'}  %s  $CNorm" .
			"$ColorHash{'Color_RepoDir'}%s$CNorm" .
			"$ColorHash{'Color_Repo'}%s $CNorm" .
			"$ColorHash{'Color_Status'}%s$CNorm",
			$Sym, $DirName, $BaseName, $Desc
		)
	}else{
		$Result = sprintf(
			"$ColorHash{'Color_Symbol'}  %s  $CNorm" .
			"$ColorHash{'Color_RepoDir'}%s$CNorm" .
			"$ColorHash{'Color_Repo'}%s\n$CNorm" .
			"$ColorHash{'Color_Status'}     %s$CNorm",
			$Sym, $DirName, $BaseName, $Desc
		);

		$Result = $Result . sprintf(
			"$ColorHash{'Color_Status'}\n\n%s$CNorm",
			$LastCom
		) if $ShowLatest eq 'true'
	}

	next if $OmitClean eq 'true' and $Desc =~ 'commit\(s\) clean';

	push(@Results, $Result)
}

if (scalar(@Results) > 0){
	my $Count;
	foreach (@Results){
		print("$_\n");
		print("\n") unless ++$Count == scalar(@Results)
			or $Compact eq 'true' or $Parseable eq 'true'
	}
}else{
	# If all repositories are clean and OmitClean is enabled, this:
	print(STDERR "Uh-oh! ...nothing to show.\n") and exit(2)
}
