#!/usr/bin/env perl

#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Tue  4 Feb 03:25:28 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
# Dependencies:
#
#   libtfl-perl (>= 2020-01-09)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean';

no warnings 'uninitialized';

my $CurVer = '2020-02-04';

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Send your Ubuntu system to the doctor for a check-up.

		SYNTAX:     $TFL::PROGNAME [OPTS]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --config PATH           - Override default file.
		            --force-reset           - Force generation of config file.

		FILE:       ~/.config/$TFL::PROGNAME/config
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP,
	$PurgeChk, $HardAPT, @SkipAPT, $SSHServer, $SSHDConfig
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}else{
			FErr(1, __LINE__, "Invalid key '$Key' detected.")
		}
	}

	close($FH)
}else{
	open(my $FH, '>', $ConfigFile);

	print($FH qq{# User configuration file for `$TFL::PROGNAME` ($CurVer)

		# If enabled, perform various checks for kernel parameters.
		KernParams=true

		# Skip (ignore) the provided kernel parameter. This can be specified
		# multiple times, using the same key, but only one value per key.
		#
		# Example: SkipKP=vm.swappiness
		#
		# No test will take place to confirm the parameter entered here is
		# actually handled by $TFL::PROGNAME, so if you wanted to have several
		# specific parameters ignored, for any future updates, it's possible.
		SkipKP=

		# If enabled, check for sane owner, group, and mode of `PATH` files.
		#
		# It's important to note that, at least for now, only the last three
		# digits of the numeric mode (for example `0755`) are checked.
		PathPerms=true

		# If enabled, look for removed packages yet to be purged. An unpurged
		# package simply means there are associated files (these are typically
		# global configurations) still remainig.
		PurgeChk=true

		# Security-bolstering APT options will be set, if this is enabled.
		HardAPT=true

		# Same applies as with `SkipKP`, but for skipping APT option checks.
		# By default, the following key is ignored, because it may seem a bit
		# excessive, but more importantly, could wind up causing dependency
		# issues for users misunderstanding their packaging operation.
		SkipAPT=APT::Install-Recommends

		# If enabled, performs various SSH Daemon security checks. This will
		# check the default location of the `sshd_config` configuration file, -
		# so if you've got the file elsewhere, you'll want to provide it below.
		SSHServer=false

		# Optionally, override the default location of the `sshd_config` file.
		SSHDConfig=/etc/ssh/sshd_config
	} =~ tr/\t//dr);

	close($FH);
	printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
	exit(0)
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	printf("[A%0.4d]: %s\n", $_[0], $_[1])
}

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		# Assume we're not running on a server.
		'1491:10:/proc/sys/vm/swappiness',

		# Log martians.
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',

		# Protects against IP spoofing.
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',

		# Not a router. Also ignores ICMP redirects.
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',

		# Block SYN attacks.
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',

		# Ignore pings.
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',

		# Restrict what users can garner from the kernel log.
		'9623:1:/proc/sys/kernel/dmesg_restrict',

		# General system security.
		'8560:1:/proc/sys/kernel/kptr_restrict',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		if (-f -r -T $Path){
			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			next
		}

		Alert($AlertID, "Key '$ShowKey' assigned '$Value'.")
			if $Value != $GoodValue and not grep(/^$ShowKey$/, @SkipKP)
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	my @AlertPerms;
	foreach (split(':', $ENV{'PATH'})){
		foreach (glob("$_/*")){
			my $Perms = sprintf('%04o', (stat($_))[2] & 07777);
			my ($Owner, $Group) = (stat($_))[4,5];

			#TODO: Does not take into account the first digit.
			Alert(7869, "File '$_' permits '$Perms'.")
				unless substr($Perms, 1) <= 755;

			# These executables should not be owned by a standard user, nor
			# should they be in such a group. <1000 is for system users/groups.
			# A stricter test (make optional?) would be to flag all non-0s.
			# There are exceptions, however, such as the user having his or her
			# own `bin` directory in their `/home` directory.
			#TODO: Add a stricter version of this, for the more paranoid.
			if ($Owner >= 1000){
				Alert(6005, "File '$_' owned by '$Owner'.")
			}elsif ($Group >= 1000){
				Alert(3597, "File '$_' in group '$Group'.")
			}
		}
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	my $DpkgStatus = '/var/lib/dpkg/status';

	# These are unlikely in an Ubuntu installation, but just in-case.
	FErr(1, __LINE__, "File '$DpkgStatus' not found.") unless -f $DpkgStatus;
	FErr(1, __LINE__, "File '$DpkgStatus' unreadable.") unless -r $DpkgStatus;
	FErr(1, __LINE__, "File '$DpkgStatus' is binary.") if -B $DpkgStatus;

	open(my $FH, '<', $DpkgStatus);

	my ($Package, $Arch, $Status, %Packages);
	while (<$FH>){
		chomp();
		next if /^$/;

		my ($Key, $Value) = split(':');

		if ($Key eq 'Package'){
			$Package = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Status'){
			$Status = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Architecture'){
			$Arch = $Value =~ tr/ //dr;

			next unless $Status eq 'deinstallokconfig-files';

			unless ($Arch eq 'all'){
				$Packages{"$Package:$Arch"} = $Status
			}else{
				$Packages{$Package} = $Status
			}
		}
	}

	close($FH);

	Alert(6712, "Package '$_' wasn't purged.") foreach sort(keys(%Packages))
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	my $VendorFile = '/etc/apt/apt.conf.d/01-vendor-ubuntu';

	if (-f -r -T $VendorFile){
		open(my $FH, '<', $VendorFile);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');
			$Value = $Value =~ tr/"';//dr;

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach (
			# These values, when set to `false`, offer much better security.
			'false|APT::Get::AllowUnauthenticated',
			'false|Acquire::http::AllowRedirect',

			# These packages aren't required, so don't clutter the system up.
			'false|APT::Install-Suggests',

			# Perhaps a bit excessive, but can also be a time-saver. This is
			# ignored by default, to avoid any issues with dependencies.
			'false|APT::Install-Recommends'
		){
			my ($Target, $Key) = split('\|');

			next if grep(/^$Key$/, @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(6131, "APT key '$Key' not assigned.")
			}elsif ($Settings{$Key} ne $Target){
				Alert(6131, "APT key '$Key' assigned '$Settings{$Key}'.")
			}
		}

	}
}

#-------------------------------------------------------------SSH Server Checks

if ($SSHServer eq 'true'){
	FErr(1, __LINE__, "File '$SSHDConfig' not found.") unless -f $SSHDConfig;
	FErr(1, __LINE__, "File '$SSHDConfig' unreadable.") unless -r $SSHDConfig;
	FErr(1, __LINE__, "File '$SSHDConfig' is binary.") if -B $SSHDConfig;

	open(my $FH, '<', $SSHDConfig);

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$)/;

		print("$_\n");

		my ($Key, $Value) = split(' ');

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach (
		# While cool, it's recommended to disable it, for security reasons.
		'no|X11Forwarding',

		# A must-have during setup, and for otherwise gaining access when
		# keys aren't working, but keep in mind that this is nowhere near
		# as safe as using cryptographic keys. Disables "tunneled clear
		# text passwords", as it says in the default `sshd_config`
		# configuration file.
		'no|PasswordAuthentication',
		'no|PermitEmptyPasswords',
	){
		my ($Target, $Key) = split('\|');

		next if grep(/^$Key$/, @SkipAPT);

		unless (exists($Settings{$Key})){
			Alert(7541, "SSH daemon key '$Key' not assigned.")
		}elsif ($Settings{$Key} ne $Target){
			Alert(7541, "SSH daemon key '$Key' assigned '$Settings{$Key}'.")
		}
	}

	# Ordinarily, you shouldn't use the commonplace `22` port.
	unless (exists($Settings{'Port'})){
		Alert(7541, "SSH daemon key 'Port' not assigned.")
	}elsif ($Settings{'Port'} eq 22){
		Alert(7541, "SSH daemon key 'Port' assigned '$Settings{Port}'.")
	}
}
