#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Thu  6 Feb 19:09:03 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
#TODO: Add ANSI color support and configuration items for it.
#TODO: Add SSH permission checks for ~/.ssh and contents.
#TODO: Add a stricter ownership PATH check, for the more paranoid.
#TODO: Add option to automatically display database entries for alerts.
#TODO: Add permission and ownership check for directories like `/boot`.
#TODO: Add update feature, because it's important to keep this updated.
#TODO: Check filesystem sizes (akin to `df`, but pure-Perl).
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Have a grep check for the SystemD section, to ignore certain keys.
#TODO: Somehow handle the first digit in `stat()` mode.
#
# Dependencies:
#
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   libtfl-perl (>= 2020-01-09)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean', 'DepChk';

no warnings 'uninitialized';

my $CurVer = '2020-02-06';

my $DefaultConfigFile = "/usr/share/$TFL::PROGNAME/$TFL::PROGNAME.conf";

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Send your Ubuntu system to the doctor for a check-up.

		SYNTAX:     $TFL::PROGNAME [OPTS]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --config PATH           - Override default file.
		            --force-reset           - Force generation of config file.
		            --is-ubuntu|-U          - Execute as though in Ubuntu.
		            --query|-Q N            - Read about alert ID number N.
		            --skip=N[,N ...]        - Skip one or more N alerts, by ID.
		            --summary|-S            - Conclude with a brief summary.
		            --verbose|-V            - Execute checks verbosely.

		NOTE:       A valid alert ID is 4 digits, IE: 5248

		EXAMPLE:    $TFL::PROGNAME -V --skip=5754,7416
		            $TFL::PROGNAME -Q 8471

		FILE:       The user's own configuration file:

		              ~/.config/$TFL::PROGNAME/config

		            The default configuration file:

		              $DefaultConfigFile

		SITE:       $Domain
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $IsUbuntu, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $Firewall, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $ShowSummary, $AlertCount, $Recommend
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif($ARGV[0] =~ '^(--query|-Q)$'){
		shift();

		FErr(1, __LINE__, "Option '--query|-Q' requires an alert ID.")
			unless length($ARGV[0]) > 0;

		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless $ARGV[0] =~ '^[0-9]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif($ARGV[0] =~ '^--skip='){
		@SkipIDs = split(',', $ARGV[0] =~ s/^--skip=//r);

		FErr(1, __LINE__, "Option '--skip=' requires at least one alert ID.")
			unless @SkipIDs > 0;

		foreach (@SkipIDs){
			FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
				unless /^[0-9]{4}$/;
		}
	}elsif($ARGV[0] =~ '^(--is-ubuntu|-U)$'){
		$IsUbuntu = 'true'
	}elsif($ARGV[0] =~ '^(--verbose|-V)$'){
		$Verbose = 'true'
	}elsif($ARGV[0] =~ '^(--summary|-S)$'){
		$ShowSummary = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

#-----------------------------------------------------Miscellaneous Subroutines

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	unless (grep(/^$_[0]$/, @SkipIDs)){
		$AlertCount++;

		printf("[A%0.4d]: %s\n", $_[0], $_[1]);

		printf("       + %s\n", $_[2])
			if $Recommend eq 'true' and length($_[2]) > 0
	}
}

sub FileChk{ # Usage: [FILE]
	FErr(1, __LINE__, "File '$_[0]' not found.") unless -f $_[0];
	FErr(1, __LINE__, "File '$_[0]' unreadable.") unless -r $_[0];
	FErr(1, __LINE__, "File '$_[0]' is binary.") if -B $_[0];

	Info("Checking '$_[0]' file.")
}

#---------------------------------------------------------------------LSB Check

unless ($IsUbuntu eq 'true'){
	my $OSRelease = '/etc/os-release';

	FileChk($OSRelease);
	open(my $FH, '<', $OSRelease);

	my ($LSB, $Found);
	while (<$FH>){
		chomp();
		next if /(^$|^#)/;
		next unless /^ID=ubuntu$/;

		$Found = 'true';

		last
	}

	close($FH);

	FErr(1, __LINE__, "Your distribution is not supported.")
		unless $Found eq 'true'
}

#-------------------------------------Configuration File Parsing and Generation

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'IsUbuntu'){
			Boolean($Value);
			$IsUbuntu = $Value unless $IsUbuntu eq 'true'
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'Firewall'){
			Boolean($Value);
			$Firewall = $Value
		}elsif ($Key eq 'SystemD'){
			Boolean($Value);
			$SystemD = $Value
		}elsif ($Key eq 'KernMods'){
			Boolean($Value);
			$KernMods = $Value
		}elsif ($Key eq 'CustomKMs'){
			push(@CustomKMs, $Value)
		}elsif ($Key eq 'SkipKMs'){
			push(@SkipKMs, $Value)
		}elsif ($Key eq 'SkipIDs'){
			push(@SkipIDs, split(',', $Value))
		}elsif ($Key eq 'ShowSummary'){
			Boolean($Value);
			$ShowSummary = $Value unless $ShowSummary eq 'true'
		}elsif ($Key eq 'Recommend'){
			Boolean($Value);
			$Recommend = $Value
		}else{
			FErr(1, __LINE__, "Invalid key '$Key' detected.")
		}
	}

	close($FH)
}else{
	use File::Copy 'copy';

	FileChk($DefaultConfigFile);
	copy($DefaultConfigFile, $ConfigFile)
		or FErr(1, __LINE__, "Failed to generate a configuration file.");

	printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
	exit(0)
}

if (@SkipIDs > 0){
	foreach (@SkipIDs){
		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless /^[0-9]{4}$/
	}
}

#-------------------------------------------------------------Querying an Alert

if ($Query eq 'true'){
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	my $Database = '/usr/share/ubuchk/ubuchk-db';

	unless (-f $Database){
		if (DepChk(':', 'cito') == 0){
			FErr(0, __LINE__, "File '$Database' not found -- run:")
				unless -f $Database;

			print(
				STDERR "cito -r terminalforlife PerlProjects " .
				"ubuchk_project source/ubuchk-db\n"
			);

			exit(1)
		}else{
			FErr(1, __LINE__, "File '$Database' not found")
		}
	}

	FErr(1, __LINE__, "File '$Database' unreadable.") unless -r $Database;

	open(my $FH, '<', $Database);

	my ($Found, @Body);
	while (<$FH>){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	close($FH);

	FErr(1, __LINE__, "Alert '$HelpAlertID' not found -- are we up-to-date?")
		unless $Found eq 'true';

	$Text::Wrap::columns = (GetTerminalSize())[0];

	print("Alert #$HelpAlertID:\n");
	print(wrap("\n  ", '  ', "$_\n")) foreach @Body;

	exit(0)
}

#-------------------------------------------DPKG Status File Parsing Subroutine

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	FileChk($DpkgStatus);
	open(my $FH, '<', $DpkgStatus);

	my ($Package, $Arch, $Status, @Packages);
	while (<$FH>){
		chomp();
		next if /^$/;

		my ($Key, $Value) = split(':');

		if ($Key eq 'Package'){
			$Package = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Status'){
			$Status = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Architecture'){
			$Arch = $Value =~ tr/ //dr;

			next unless $Status eq $_[0];

			push(@Packages, "$Package:$Arch")
		}
	}

	close($FH);

	return(sort(@Packages))
}

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		Info("Checking '$ShowKey' parameter.");

		if (-f -r -T $Path){
			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			next
		}

		Info("File '$Path' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue and not grep(/^$ShowKey$/, @SkipKP)
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	my @AlertPerms;
	foreach (split(':', $ENV{'PATH'})){
		Info("Looking in '$_' directory.");

		foreach (glob("$_/*")){
			# This is a little excessive.
			#Info("Checking '$_' file.");

			my $Perms = sprintf('%04o', (stat($_))[2] & 07777);
			my ($Owner, $Group) = (stat($_))[4,5];

			# This is a little excessive, too.
			#Info("File is '$Perms' and '$Owner:$Group'.");

			Alert(
				7869,
				"File '$_' permits '$Perms'.",
				"Recommended permissions are '755'."
			) unless substr($Perms, 1) <= 755;

			# These executables should not be owned by a standard user, nor
			# should they be in such a group. <1000 is for system users/groups.
			# A stricter test (make optional?) would be to flag all non-0s.
			# There are exceptions, however, such as the user having his or her
			# own `bin` directory in their `/home` directory.
			if ($Owner >= 1000){
				Alert(
					6005,
					"File '$_' owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				)
			}elsif ($Group >= 1000){
				Alert(
					3597,
					"File '$_' in group '$Group'.",
					"Recommended group is '0' ('root')."
				)
			}
		}
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for unwanted packages.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach sort(ParseDpkgStatus('deinstallokconfig-files'))
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	my $VendorFile = '/etc/apt/apt.conf.d/01-vendor-ubuntu';

	FileChk($VendorFile);
	open(my $FH, '<', $VendorFile);

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$)/;

		my ($Key, $Value) = split(' ');
		$Value = $Value =~ tr/"';//dr;

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach ( # [TARGET_VALUE] [KEY]
		'false|APT::Get::AllowUnauthenticated',
		'false|Acquire::http::AllowRedirect',
		'false|APT::Install-Suggests',
		'false|APT::Install-Recommends'
	){
		my ($Target, $Key) = split('\|');

		next if grep(/^$Key$/, @SkipAPT);

		unless (exists($Settings{$Key})){
			Alert(
				6131,
				"APT key '$Key' not assigned.",
				"Recommended action is to assign it '$Target'."
			)
		}elsif ($Settings{$Key} ne $Target){
			Alert(
				6221,
				"APT key '$Key' assigned '$Settings{$Key}'.",
				"Recommended value is '$Target'."
			)
		}
	}
}

#-------------------------------------------------------------SSH Server Checks

if ($SSHServer eq 'true'){
	FileChk($SSHDConfig);
	open(my $FH, '<', $SSHDConfig);

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$)/;

		print("$_\n");

		my ($Key, $Value) = split(' ');

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach ( # [TARGET_VALUE] [KEY]
		'no|X11Forwarding',
		'no|PasswordAuthentication',
		'no|PermitEmptyPasswords',
	){
		my ($Target, $Key) = split('\|');

		next if grep(/^$Key$/, @SkipAPT);

		unless (exists($Settings{$Key})){
			Alert(
				7541,
				"SSH daemon key '$Key' not assigned.",
				"Recommended action is to assign it '$Target'."
			)
		}elsif ($Settings{$Key} ne $Target){
			Alert(
				6542,
				"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
				"Recommended value is '$Target'."
			)
		}
	}

	# Ordinarily, you shouldn't use the commonplace `22` port.
	unless (exists($Settings{'Port'})){
		Alert(
			7541,
			"SSH daemon key 'Port' not assigned.",
			"Recommended action is NOT to assign it '22'."
		)
	}elsif ($Settings{'Port'} eq 22){
		Alert(
			6542,
			"SSH daemon key 'Port' assigned '$Settings{Port}'.",
			"Recommended value is one other than '22'."
		)
	}
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package '$CurPKG' installed.",
			"Recommended action is to uninstall the package."
		) if grep(/^$CurPKG$/, ParseDpkgStatus('installokinstalled'))
	}
}

#------------------------------------------------------------UFW Firewall Check

if ($Firewall eq 'true' and DepChk(':', 'ufw') == 0){
	Info("Found the 'ufw' executable in PATH.");

	if (DepChk(':', 'systemctl') == 0){
		Info("Found 'systemctl' executable in PATH.");
		Info('Finding out if UFW unit is active.');

		chomp(my $Result = `systemctl is-active ufw 2> /dev/null`);
		unless ($Result eq 'active'){
			Alert(
				5541,
				'The UFW service is inactive.',
				"Recommended action is to enable the service, ASAP."
			)
		}else{
			Info('Active UFW service detected.')
		}
	}else{
		FErr(1, __LINE__, "Dependency 'systemctl' not met.")
	}
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true'){
	my $SDConfig = '/etc/systemd/system.conf';

	FileChk($SDConfig);
	open(my $FH, '<', $SDConfig);

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$|^\[Manager\]$)/;

		my ($Key, $Value) = split('=');

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach ( # [TARGET_VALUE] [KEY]
		'1024|DefaultLimitNPROC',
		'1024|DefaultLimitNOFILE',
		'no|CrashShell',
		'no|DumpCore'
	){
		my ($Target, $Key) = split('\|');

		unless (exists($Settings{$Key})){
			Alert(
				5754,
				"SystemD key '$Key' not assigned.",
				"Recommended action is to assign it '$Target'."
			)
		}elsif ($Settings{$Key} ne $Target){
			Alert(
				3421,
				"SystemD key '$Key' assigned '$Settings{$Key}'.",
				"Recommended value is '$Target'."
			)
		}
	}
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true'){
	my $ProcMods = '/proc/modules';

	FileChk($ProcMods);
	open(my $FH, '<', $ProcMods);

	my @Modules;
	while (<$FH>){
		chomp();

		my @Line = split(' ');

		push(@Modules, $Line[0])
	}

	close($FH);

	foreach (
		'1274|mei',
		'1274|mei_me',
		'1274|mei_wtk',
		'7416|joydev',
		'8471|psmouse'
	){
		my ($AlertID, $Module) = split('\|');

		Info("Module '$Module' not found.");

		Alert(
			$AlertID,
			"Module '$Module' discovered and live.",
			"Recommended action is to blacklist the module."
		) if grep(/^$Module$/, @Modules) and not grep(/^$Module$/, @SkipKMs)
	}

	foreach my $Mod (@CustomKMs){
		Alert(
			8189,
			"Module '$Mod' discovered and live.",
			"Recommended action is to blacklist the module."
		) if grep(/^$Mod$/, @Modules)
	}
}

#--------------------------------------------------------------Finish & Summary

Info("Done.");

# Only show the summary if set to and actually have alerts. This should be
# particularly useful if the user logs UbuChk's output.
exit(0) unless $AlertCount > 0 and $ShowSummary eq 'true';

my $Time = localtime();
my $HostNameFile = '/etc/hostname';

FileChk($HostNameFile);
open(my $FH, '<', $HostNameFile);
chomp(my $Host = <$FH>);
close($FH);

print(qq{
	  Timestamp: $Time
	   Hostname: $Host
	   Username: $ENV{USER}
	     UserID: $<
	     Alerts: $AlertCount

} =~ tr/\t//dr)
