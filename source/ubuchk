#!/usr/bin/env perl

#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Tue  4 Feb 00:36:01 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
# Dependencies:
#
#   libtfl-perl (>= 2020-01-09)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean';

no warnings 'uninitialized';

my $CurVer = '2020-02-04';

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Send your Ubuntu system to the doctor for a check-up.

		SYNTAX:     $TFL::PROGNAME [OPTS]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --config PATH           - Override default file.
		            --force-reset           - Force generation of config file.

		FILE:       ~/.config/$TFL::PROGNAME/config
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}else{
			FErr(1, __LINE__, "Invalid key '$Key' detected.")
		}
	}

	close($FH)
}else{
	open(my $FH, '>', $ConfigFile);

	print($FH qq{# User configuration file for `$TFL::PROGNAME` ($CurVer)

		# If enabled, perform various checks for kernel parameters.
		KernParams=true

		# Skip (ignore) the provided kernel parameter. This can be specified
		# multiple times, using the same key, but only one value per key.
		#
		# Example: SkipKP=vm.swappiness
		#
		# No test will take place to confirm the parameter entered here is
		# actually handled by $TFL::PROGNAME, so if you wanted to have several
		# specific parameters ignored, for any future updates, it's possible.
		SkipKP=

		# If enabled, check for sane owner, group, and mode of `PATH` files.
		#
		# It's important to note that, at least for now, only the last three
		# digits of the numeric mode (for example `0755`) are checked.
		PathPerms=true
	} =~ tr/\t//dr);

	close($FH);
	printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
	exit(0)
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	printf("[A%0.4d]: %s\n", $_[0], $_[1])
}

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		# Assume we're not running on a server.
		'1491:10:/proc/sys/vm/swappiness',

		# Log martians.
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',

		# Protects against IP spoofing.
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',

		# Not a router. Also ignores ICMP redirects.
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',

		# Block SYN attacks.
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',

		# Ignore pings.
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',

		# Restrict what users can garner from the kernel log.
		'9623:1:/proc/sys/kernel/dmesg_restrict',

		# General system security.
		'8560:1:/proc/sys/kernel/kptr_restrict',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		if (-f -r -T $Path){
			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			next
		}

		Alert($AlertID, "Key '$ShowKey' assigned '$Value'.")
			if $Value != $GoodValue and not grep(/^$ShowKey$/, @SkipKP)
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	my @AlertPerms;
	foreach (split(':', $ENV{'PATH'})){
		foreach (glob("$_/*")){
			my $Perms = sprintf('%04o', (stat($_))[2] & 07777);
			my ($Owner, $Group) = (stat($_))[4,5];

			#TODO: Does not take into account the first digit.
			Alert(7869, "File '$_' permits '$Perms'.")
				unless substr($Perms, 1) <= 755;

			# These executables should not be owned by a standard user, nor
			# should they be in such a group. <1000 is for system users/groups.
			# A stricter test (make optional?) would be to flag all non-0s.
			# There are exceptions, however, such as the user having his or her
			# own `bin` directory in their `/home` directory.
			#TODO: Add a stricter version of this, for the more paranoid.
			if ($Owner >= 1000){
				Alert(6005, "File '$_' owned by '$Owner'.")
			}elsif ($Group >= 1000){
				Alert(3597, "File '$_' in group '$Group'.")
			}
		}
	}
}
