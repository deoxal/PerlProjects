#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Wed  5 Feb 02:52:28 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
# Dependencies:
#
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   libtfl-perl (>= 2020-01-09)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean', 'DepChk';

no warnings 'uninitialized';

my $CurVer = '2020-02-05';

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Send your Ubuntu system to the doctor for a check-up.

		SYNTAX:     $TFL::PROGNAME [OPTS]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --config PATH           - Override default file.
		            --force-reset           - Force generation of config file.
		            --is-ubuntu|-U          - Execute as though in Ubuntu.
		            --query|-Q N            - Read about alert ID number N.
		            --verbose|-V            - Execute checks verbosely.

		FILE:       ~/.config/$TFL::PROGNAME/config
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $IsUbuntu, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $Firewall
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif($ARGV[0] =~ '^(--query|-Q)$'){
		shift();

		Err(1, "Invalid alert ID.") unless $ARGV[0] =~ '^[0-9]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--is-ubuntu|-U)$'){
		$IsUbuntu = 'true'
	}elsif($ARGV[0] =~ '^(--verbose|-V)$'){
		$Verbose = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

unless ($IsUbuntu eq 'true'){
	my $OSRelease = '/etc/os-release';

	FErr(1, __LINE__, "File '$OSRelease' not found.") unless -f $OSRelease;
	FErr(1, __LINE__, "File '$OSRelease' unreadable.") unless -r $OSRelease;
	FErr(1, __LINE__, "File '$OSRelease' is binary.") if -B $OSRelease;

	open(my $FH, '<', $OSRelease);

	my ($LSB, $Found);
	while (<$FH>){
		chomp();
		next if /(^$|^#)/;
		next unless /^ID=ubuntu$/;

		$Found = 'true';

		last
	}

	close($FH);

	FErr(1, __LINE__, "Your distribution is not supported.")
		unless $Found eq 'true'
}

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'IsUbuntu'){
			Boolean($Value);
			$IsUbuntu = $Value unless $IsUbuntu eq 'true'
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'Firewall'){
			Boolean($Value);
			$Firewall = $Value
		}else{
			FErr(1, __LINE__, "Invalid key '$Key' detected.")
		}
	}

	close($FH)
}else{
	open(my $FH, '>', $ConfigFile);

	print($FH qq{# User configuration file for `$TFL::PROGNAME` ($CurVer)

		# Since we're intended for use on Ubuntu distributions, and those based
		# thereon, an error will display, were it not detected. This can can be
		# overridden by enabling this key, like the `--is-ubuntu-|U` option.
		IsUbuntu=false

		# Be verbose during checks, if enabled, like the `--verbose|-V` option.
		Verbose=false

		# If enabled, perform various checks for kernel parameters.
		KernParams=true

		# Skip (ignore) the provided kernel parameter. This can be specified
		# multiple times, using the same key, but only one value per key.
		#
		# Example: SkipKP=vm.swappiness
		#
		# No test will take place to confirm the parameter entered here is
		# actually handled by $TFL::PROGNAME, so if you wanted to have several specific
		# parameters ignored, for any future updates, it's possible.
		SkipKP=

		# If enabled, check for sane owner, group, and mode of `PATH` files.
		#
		# It's important to note that, at least for now, only the last three
		# digits of the numeric mode (for example `0755`) are checked.
		PathPerms=true

		# If enabled, look for removed packages yet to be purged. An unpurged
		# package simply means there are associated files (these are typically
		# global configurations) still remainig.
		PurgeChk=true

		# Security-bolstering APT options will be set, if this is enabled.
		HardAPT=true

		# Same applies as with `SkipKP`, but for skipping APT option checks.
		# By default, the following key is ignored, because it may seem a bit
		# excessive, but more importantly, could wind up causing dependency
		# issues for users misunderstanding their packaging operation.
		SkipAPT=APT::Install-Recommends

		# If enabled, performs various SSH Daemon security checks. This will
		# check the default location of the `sshd_config` configuration file, -
		# so if you've got the file elsewhere, you'll want to provide it below.
		SSHServer=false

		# Optionally, override the default location of the `sshd_config` file.
		SSHDConfig=/etc/ssh/sshd_config

		# These packages are potentially unwanted, so will be checked to see if
		# they are installed. Additional packages can be provided below. You
		# must specify the exact architecture which you're targetting.
		UnwantedPKGs=virtualbox-guest-dkms:all
		UnwantedPKGs=virtualbox-guest-utils:all

		# If enabled, check that the Uncomplicated FireWall (UFW) service
		# (unit) is active. If the UFW executable is not found in PATH, then
		# this check will be skipped.
		Firewall=true
	} =~ tr/\t//dr);

	close($FH);
	printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
	exit(0)
}

#-------------------------------------------------------------Querying an Alert

if ($Query eq 'true'){
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	my $Database = '/usr/share/ubuchk/ubuchk-db';

	FErr(1, __LINE__, "File '$Database' not found.") unless -f $Database;
	FErr(1, __LINE__, "File '$Database' unreadable.") unless -r $Database;

	open(my $FH, '<', $Database);

	my ($Found, @Body);
	while (<$FH>){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	close($FH);

	FErr(1, __LINE__, "Alert '$HelpAlertID' not found.")
		unless $Found eq 'true';

	$Text::Wrap::columns = (GetTerminalSize())[0];

	print("Alert #$HelpAlertID:\n");
	print(wrap("\n  ", '  ', "$_\n")) foreach @Body;

	exit(0)
}

#-------------------------------------------------------------------Subroutines

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	printf("[A%0.4d]: %s\n", $_[0], $_[1])
}

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	# These are unlikely in an Ubuntu installation, but just in-case.
	FErr(1, __LINE__, "File '$DpkgStatus' not found.") unless -f $DpkgStatus;
	FErr(1, __LINE__, "File '$DpkgStatus' unreadable.") unless -r $DpkgStatus;
	FErr(1, __LINE__, "File '$DpkgStatus' is binary.") if -B $DpkgStatus;

	open(my $FH, '<', $DpkgStatus);

	my ($Package, $Arch, $Status, @Packages);
	while (<$FH>){
		chomp();
		next if /^$/;

		my ($Key, $Value) = split(':');

		if ($Key eq 'Package'){
			$Package = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Status'){
			$Status = $Value =~ tr/ //dr;
		}elsif ($Key eq 'Architecture'){
			$Arch = $Value =~ tr/ //dr;

			next unless $Status eq $_[0];

			push(@Packages, "$Package:$Arch")
		}
	}

	close($FH);

	return(sort(@Packages))
}

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'1491:10:/proc/sys/vm/swappiness',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'8560:1:/proc/sys/kernel/kptr_restrict',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		Info("Checking '$ShowKey' parameter.");

		if (-f -r -T $Path){
			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			next
		}

		Info("File '$Path' is '$Value'.");

		Alert($AlertID, "Key '$ShowKey' assigned '$Value'.")
			if $Value != $GoodValue and not grep(/^$ShowKey$/, @SkipKP)
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	my @AlertPerms;
	foreach (split(':', $ENV{'PATH'})){
		Info("Looking in '$_' directory.");

		foreach (glob("$_/*")){
			Info("Checking '$_' file.");

			my $Perms = sprintf('%04o', (stat($_))[2] & 07777);
			my ($Owner, $Group) = (stat($_))[4,5];

			Info("Mode of file '$_' is '$Perms'.");
			Info("Owner of file '$_' is '$Owner'.");
			Info("Group of file '$_' is '$Group'.");

			#TODO: Does not take into account the first digit.
			Alert(7869, "File '$_' permits '$Perms'.")
				unless substr($Perms, 1) <= 755;

			# These executables should not be owned by a standard user, nor
			# should they be in such a group. <1000 is for system users/groups.
			# A stricter test (make optional?) would be to flag all non-0s.
			# There are exceptions, however, such as the user having his or her
			# own `bin` directory in their `/home` directory.
			#TODO: Add a stricter version of this, for the more paranoid.
			if ($Owner >= 1000){
				Alert(6005, "File '$_' owned by '$Owner'.")
			}elsif ($Group >= 1000){
				Alert(3597, "File '$_' in group '$Group'.")
			}
		}
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for unwanted packages.");

	Alert(6712, "Package '$_' wasn't purged.")
		foreach sort(ParseDpkgStatus('deinstallokconfig-files'))
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	my $VendorFile = '/etc/apt/apt.conf.d/01-vendor-ubuntu';

	FErr(1, __LINE__, "File '$VendorFile' not found.") unless -f $VendorFile;
	FErr(1, __LINE__, "File '$VendorFile' unreadable.") unless -r $VendorFile;
	FErr(1, __LINE__, "File '$VendorFile' is binary.") if -B $VendorFile;

	open(my $FH, '<', $VendorFile);

	Info("Checking '$VendorFile' file.");

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$)/;

		my ($Key, $Value) = split(' ');
		$Value = $Value =~ tr/"';//dr;

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach (
		# These values, when set to `false`, offer much better security.
		'false|APT::Get::AllowUnauthenticated',
		'false|Acquire::http::AllowRedirect',

		# These packages aren't required, so don't clutter the system up.
		'false|APT::Install-Suggests',

		# Perhaps a bit excessive, but can also be a time-saver. This is
		# ignored by default, to avoid any issues with dependencies.
		'false|APT::Install-Recommends'
	){
		my ($Target, $Key) = split('\|');

		next if grep(/^$Key$/, @SkipAPT);

		unless (exists($Settings{$Key})){
			Alert(6131, "APT key '$Key' not assigned.")
		}elsif ($Settings{$Key} ne $Target){
			Alert(6221, "APT key '$Key' assigned '$Settings{$Key}'.")
		}
	}
}

#-------------------------------------------------------------SSH Server Checks

if ($SSHServer eq 'true'){
	FErr(1, __LINE__, "File '$SSHDConfig' not found.") unless -f $SSHDConfig;
	FErr(1, __LINE__, "File '$SSHDConfig' unreadable.") unless -r $SSHDConfig;
	FErr(1, __LINE__, "File '$SSHDConfig' is binary.") if -B $SSHDConfig;

	open(my $FH, '<', $SSHDConfig);

	Info("Checking '$SSHDConfig' file.");

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$)/;

		print("$_\n");

		my ($Key, $Value) = split(' ');

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach (
		# While cool, it's recommended to disable it, for security reasons.
		'no|X11Forwarding',

		# A must-have during setup, and for otherwise gaining access when
		# keys aren't working, but keep in mind that this is nowhere near
		# as safe as using cryptographic keys. Disables "tunneled clear
		# text passwords", as it says in the default `sshd_config`
		# configuration file.
		'no|PasswordAuthentication',
		'no|PermitEmptyPasswords',
	){
		my ($Target, $Key) = split('\|');

		next if grep(/^$Key$/, @SkipAPT);

		unless (exists($Settings{$Key})){
			Alert(7541, "SSH daemon key '$Key' not assigned.")
		}elsif ($Settings{$Key} ne $Target){
			Alert(6542, "SSH daemon key '$Key' assigned '$Settings{$Key}'.")
		}
	}

	# Ordinarily, you shouldn't use the commonplace `22` port.
	unless (exists($Settings{'Port'})){
		Alert(7541, "SSH daemon key 'Port' not assigned.")
	}elsif ($Settings{'Port'} eq 22){
		Alert(6542, "SSH daemon key 'Port' assigned '$Settings{Port}'.")
	}
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(5656, "Package '$CurPKG' installed.")
			if grep(/^$CurPKG$/, ParseDpkgStatus('installokinstalled'))
	}
}

#------------------------------------------------------------UFW Firewall Check

#TODO: Find a way to check this without the use of `systemctl` executable.
if ($Firewall eq 'true' and DepChk(':', 'ufw') == 0){
	Info("Found the 'ufw' executable in PATH.");

	if (DepChk(':', 'systemctl') == 0){
		Info("Found 'systemctl' executable in PATH.");

		Info('Finding out if UFW unit is active.');

		chomp(my $Result = `systemctl is-active ufw`);
		unless ($Result eq 'active'){
			Alert(5541, 'The UFW service is inactive.')
		}else{
			Info('Active UFW service detected.')
		}
	}else{
		FErr(1, __LINE__, "Dependency 'systemctl' not met.")
	}
}
