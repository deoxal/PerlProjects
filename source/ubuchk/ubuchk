#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Fri  7 Feb 21:13:59 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
#TODO: Add ANSI color support and configuration items for it.
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add a stricter ownership PATH check, for the more paranoid.
#TODO: Add permission and ownership check for directories like `/boot`.
#TODO: Add update feature, because it's important to keep this updated.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Have a grep check for the SystemD section, to ignore certain keys.
#TODO: Somehow handle the first digit in `stat()` mode.
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   libtfl-perl (>= 2020-01-09)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL 'FErr', 'Boolean', 'DepChk';

no warnings 'uninitialized';

my $CurVer = '2020-02-07';

my $DefaultConfigFile = "/usr/share/$TFL::PROGNAME/config";

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage{
	print(qq{            @{[uc($TFL::PROGNAME)]} ($CurVer)
		            $TFL::AUTHOR

		            Send your Ubuntu system to the doctor for a check-up.

		SYNTAX:     $TFL::PROGNAME [OPTS]

		OPTS:       --help|-h|-?            - Display this help information.
		            --version|-v            - Output the version datestamp.
		            --force-reset           - Force generation of config file.
		            --is-ubuntu|-U          - Execute as though in Ubuntu.
		            --query|-Q N            - Read about alert ID number N.
		            --skip=N[,N ...]        - Skip one or more N alerts, by ID.
		            --verbose|-V            - Execute checks verbosely.

		NOTE:       A valid alert ID is 4 digits, IE: 5248

		EXAMPLE:    $TFL::PROGNAME -V --skip=5754,7416
		            $TFL::PROGNAME -Q 8471

		SITE:       $Domain
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $IsUbuntu, $PurgeChk, $HardAPT, @SkipAPT, $SSHSerCli,
	$SSHDConfig, $Verbose, $Firewall, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $ShowSummary, $AlertCount, $Recommend, $SSHClient,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif($ARGV[0] =~ '^(--query|-Q)$'){
		shift();

		FErr(1, __LINE__, "Option '--query|-Q' requires an alert ID.")
			unless length($ARGV[0]) > 0;

		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless $ARGV[0] =~ '^[0-9]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif($ARGV[0] =~ '^--skip='){
		@SkipIDs = split(',', $ARGV[0] =~ s/^--skip=//r);

		FErr(1, __LINE__, "Option '--skip=' requires at least one alert ID.")
			unless @SkipIDs > 0;

		foreach (@SkipIDs){
			FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
				unless /^[0-9]{4}$/;
		}
	}elsif($ARGV[0] =~ '^(--is-ubuntu|-U)$'){
		$IsUbuntu = 'true'
	}elsif($ARGV[0] =~ '^(--verbose|-V)$'){
		$Verbose = 'true'
	}elsif($ARGV[0] =~ '^(--summary|-S)$'){
		$ShowSummary = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

#-----------------------------------------------------Miscellaneous Subroutines

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub FileChk{ # Usage: [FILE]
	my $Err;
	unless (-r $_[0]){
		FErr(0, __LINE__, "File '$_[0]' unreadable."); $Err++
	}elsif (-B $_[0]){
		FErr(0, __LINE__, "File '$_[0]' is binary."); $Err++
	}

	exit(1) if $Err > 0;

	# Don't want the summary, if shown, to be cluttered here.
	return if $_[0] eq '/etc/hostname';

	Info("Checking '$_[0]' file.")
}

sub QueryAlert{
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	my $Database = '/usr/share/ubuchk/database';
	$HelpAlertID = $_[1] if length($HelpAlertID) == 0;

	unless (-f $Database){
		if (DepChk(':', 'cito') == 0){
			FErr(0, __LINE__, "File '$Database' not found -- run:")
				unless -f $Database;

			print(
				STDERR "cito -r terminalforlife PerlProjects " .
				"master source/ubuchk/database\n"
			);

			exit(1)
		}else{
			FErr(1, __LINE__, "File '$Database' not found")
		}
	}

	FErr(1, __LINE__, "File '$Database' unreadable.") unless -r $Database;

	open(my $FH, '<', $Database);

	my ($Found, @Body);
	while (<$FH>){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	close($FH);

	FErr(1, __LINE__, "Alert '$HelpAlertID' not found -- are we up-to-date?")
		unless $Found eq 'true';

	$Text::Wrap::columns = (GetTerminalSize())[0] - 1;

	# Corrects formatting when `AutoQuery` is or isn't used.
	unless (length($_[1]) > 0){
		print("Alert #$HelpAlertID:\n");
		print(wrap("  ", '  ', "\n$_\n")) foreach @Body
	}else{
		foreach (@Body){
			# Ensures paragraphing works properly. The database must have a
			# single period (`.`) on an otherwise empty line, for this to work.
			print("\n") and next if $_ eq '.';

			print(wrap(" " x $QueryIndent, ' ' x $QueryIndent, "$_\n"));
		}
	}

	exit($_[0]) unless $_[1] > 0;

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	unless (grep(/^$_[0]$/, @SkipIDs)){
		$AlertCount++;

		printf("[A%0.4d]: %s\n", $_[0], $_[1]);

		printf("       + %s\n\n", $_[2])
			if $Recommend eq 'true' and length($_[2]) > 0;

		if ($AutoQuery eq 'true'){
			# Don't want to keep showing the same query.
			unless (grep(/^$_[0]$/, @ShownAlerts)){
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	}
}

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	unless (-f $DpkgStatus){
		FErr(0, __LINE__, "File '$DpkgStatus' not found.")
	}else{
		FileChk($DpkgStatus);
		open(my $FH, '<', $DpkgStatus);

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>){
			chomp();
			next if /^$/;

			my ($Key, $Value) = split(':');

			if ($Key eq 'Package'){
				$Package = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Status'){
				$Status = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Architecture'){
				$Arch = $Value =~ tr/ //dr;

				next unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH);

		Info("Finished with '$DpkgStatus' file.");

		return(sort(@Packages))
	}
}

#---------------------------------------------------------------------LSB Check

unless ($IsUbuntu eq 'true'){
	my $OSRelease = '/etc/os-release';

	FileChk($OSRelease);
	open(my $FH, '<', $OSRelease);

	my ($LSB, $Found);
	while (<$FH>){
		chomp();
		next if /(^$|^#)/;
		next unless /^ID=ubuntu$/;

		$Found = 'true';

		last
	}

	close($FH);

	FErr(1, __LINE__, "Your distribution is not supported.")
		unless $Found eq 'true'
}

#-------------------------------------Configuration File Parsing and Generation

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'IsUbuntu'){
			Boolean($Value);
			$IsUbuntu = $Value unless $IsUbuntu eq 'true'
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHSerCli'){
			Boolean($Value);
			$SSHSerCli = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'Firewall'){
			Boolean($Value);
			$Firewall = $Value
		}elsif ($Key eq 'SystemD'){
			Boolean($Value);
			$SystemD = $Value
		}elsif ($Key eq 'KernMods'){
			Boolean($Value);
			$KernMods = $Value
		}elsif ($Key eq 'CustomKMs'){
			push(@CustomKMs, $Value)
		}elsif ($Key eq 'SkipKMs'){
			push(@SkipKMs, $Value)
		}elsif ($Key eq 'SkipIDs'){
			push(@SkipIDs, split(',', $Value))
		}elsif ($Key eq 'ShowSummary'){
			Boolean($Value);
			$ShowSummary = $Value unless $ShowSummary eq 'true'
		}elsif ($Key eq 'Recommend'){
			Boolean($Value);
			$Recommend = $Value
		}elsif ($Key eq 'DiskSpace'){
			Boolean($Value);
			$DiskSpace = $Value
		}elsif ($Key eq 'AutoQuery'){
			Boolean($Value);
			$AutoQuery = $Value
		}elsif ($Key eq 'QueryIndent'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 9;

				$QueryIndent = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DSLimit'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value >= 10 and $Value <= 100;

				$DSLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}else{
			FErr(0, __LINE__, "Invalid key '$Key' detected.");

			$InvalidKeyCount++
		}
	}

	close($FH);

	exit(1) if $InvalidKeyCount > 0
}else{
	use File::Copy 'copy';

	if (-f $DefaultConfigFile){
		FileChk($DefaultConfigFile);
		copy($DefaultConfigFile, $ConfigFile)
			or FErr(1, __LINE__, "Failed to generate a configuration file.");

		printf("File '~/.config/$TFL::PROGNAME/config' generated -- please restart.\n");
		exit(0)
	}else{
		FErr(1, __LINE__, "File '/usr/share/$TFL::PROGNAME/config' not found.")
	}
}

if (@SkipIDs > 0){
	foreach (@SkipIDs){
		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless /^[0-9]{4}$/
	}
}

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path){
			unless (-r -T $Path){
				FErr(0, __LINE__, "Unable to determine '$ShowKey' parameter.");
				next
			}

			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			Info("Parameter '$ShowKey' unavailable.");

			next
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue and not grep(/^$ShowKey$/, @SkipKP)
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	my @AlertPerms;
	foreach (split(':', $ENV{'PATH'})){
		Info("Looking in '$_' directory.");

		foreach (glob("$_/*")){
			# This is a little excessive.
			#Info("Checking '$_' file.");

			my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
			$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

			# This is a little excessive, too.
			#Info("File is '$Mode' and '$Owner:$Group'.");

			Alert(
				7869,
				"File '$_' permits '$Mode'.",
				"Recommended permissions are '755'."
			) unless substr($Mode, 1) <= 755;

			# These executables should not be owned by a standard user, nor
			# should they be in such a group. <1000 is for system users/groups.
			# A stricter test (make optional?) would be to flag all non-0s.
			# There are exceptions, however, such as the user having his or her
			# own `bin` directory in their `/home` directory.
			Alert(
				6005,
				"File '$_' owned by '$Owner'.",
				"Recommended owner is '0' ('root')."
			) if $Owner >= 1000;

			Alert(
				3597,
				"File '$_' in group '$Group'.",
				"Recommended group is '0' ('root')."
			) if $Group >= 1000
		}
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for old package remains.");

	my @Data = ParseDpkgStatus('deinstallokconfig-files');

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach sort(@Data);

	Info('No packages were found unpurged.') if @Data == 0
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	my $VendorFile = '/etc/apt/apt.conf.d/01-vendor-ubuntu';

	unless (-f $VendorFile){
		Alert(
			5411,
			"File '$VendorFile' not found.",
			"Create the file in question, then re-run UbuChk."
		)
	}else{
		FileChk($VendorFile);
		open(my $FH, '<', $VendorFile);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');
			$Value = $Value =~ tr/"';//dr;

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|false|APT::Get::AllowUnauthenticated',
			'6136|6132|false|Acquire::http::AllowRedirect',
			'6137|6133|false|APT::Install-Suggests',
			'6138|6134|false|APT::Install-Recommends'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep(/^$Key$/, @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"APT key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"APT key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	}
}

#----------------------------------------------------SSH Client & Server Checks

if ($SSHSerCli eq 'true'){
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir){
		FErr(1, __LINE__, "Directory '$SSHDir' unreadable.") unless -r $SSHDir;
		FErr(1, __LINE__, "Directory '$SSHDir' is binary.") unless -x $SSHDir;

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended permissions are '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended owner is your UID ('$<')."
		) unless $Owner == $<;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended group is your GID ('$(')."
		) unless $Group == $(;
	}

	if (-f $SSHDConfig){
		FErr(1, __LINE__, "File '$SSHDConfig' unreadable.") unless -r $SSHDConfig;
		FErr(1, __LINE__, "File '$SSHDConfig' is binary.") if -B $SSHDConfig;

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'6998|6995|no|X11Forwarding',
			'6997|6994|no|PasswordAuthentication',
			'6996|6993|no|PermitEmptyPasswords',
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep(/^$Key$/, @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})){
			Alert(
				7541,
				"SSH daemon key 'Port' not assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		}elsif ($Settings{'Port'} eq 22){
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	}
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested action is to uninstall the package(s)."
		) if grep(/$CurPKG/, ParseDpkgStatus('installokinstalled'))
	}
}

#------------------------------------------------------------UFW Firewall Check

if ($Firewall eq 'true' and DepChk(':', 'ufw') == 0){
	Info("Found the 'ufw' executable in PATH.");

	if (DepChk(':', 'systemctl') == 0){
		Info("Found 'systemctl' executable in PATH.");
		Info('Finding out if UFW unit is active.');

		chomp(my $Result = `systemctl is-active ufw 2> /dev/null`);
		unless ($Result eq 'active'){
			Alert(
				5541,
				'The UFW service is inactive.',
				"Recommended action is to enable the service, ASAP."
			)
		}else{
			Info('Active UFW service detected.')
		}
	}else{
		FErr(1, __LINE__, "Dependency 'systemctl' not met.")
	}
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true'){
	my $SDConfig = '/etc/systemd/system.conf';

	FileChk($SDConfig);
	open(my $FH, '<', $SDConfig);

	my %Settings;
	while (<$FH>){
		chomp();
		next if /(^#|^$|^\[Manager\]$)/;

		my ($Key, $Value) = split('=');

		Info("Key '$Key' is '$Value'.");

		$Settings{$Key} = $Value
	}

	close($FH);

	foreach ( # [TARGET_VALUE] [KEY]
		'1411|1415|1024|DefaultLimitNPROC',
		'1412|1416|1024|DefaultLimitNOFILE',
		'1413|1417|no|CrashShell',
		'1414|1418|no|DumpCore'
	){
		my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

		unless (exists($Settings{$Key})){
			Alert(
				$AlertID1,
				"SystemD key '$Key' not assigned.",
				"Recommended action is to assign it '$Target'."
			)
		}elsif ($Settings{$Key} ne $Target){
			Alert(
				$AlertID2,
				"SystemD key '$Key' assigned '$Settings{$Key}'.",
				"Recommended value is '$Target'."
			)
		}
	}
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true'){
	my $ProcMods = '/proc/modules';

	FileChk($ProcMods);
	open(my $FH, '<', $ProcMods);

	my @Modules;
	while (<$FH>){
		chomp();

		my @Line = split(' ');

		push(@Modules, $Line[0])
	}

	close($FH);

	foreach (
		'1274|mei',
		'1275|mei_me',
		'1276|mei_wtk',
		'7416|joydev',
		'8471|psmouse'
	){
		my ($AlertID, $Module) = split('\|');

		if (grep(/^$Module$/, @Modules)){
			unless (grep(/^$Module$/, @SkipKMs)){
				Info("Module '$Module' found but ignored.");
				next # <-- Skipping the below alert.
			}

			Alert(
				$AlertID,
				"Module '$Module' discovered and live.",
				"Recommended action is to blacklist the module."
			)
		}else{
			Info("Module '$Module' not found.")
		}
	}

	foreach my $Mod (@CustomKMs){
		Alert(
			8189,
			"Module '$Mod' discovered and live.",
			"Recommended action is to blacklist the module."
		) if grep(/^$Mod$/, @Modules)
	}
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true'){
	my $MountFile = '/proc/mounts';

	unless (-f $MountFile){
		FErr(0, __LINE__, "File '$MountFile' not found.") unless -f $MountFile;
	}else{
		use Filesys::DiskSpace 'df';

		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my (@MountPoints, $Used, $Free, $Size, $Mount, $Perc);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			if (/^\//){
				# Excessive, perhaps.
				#Info("Looking at '$Arr[0]' partition.");

				$Mount = $Arr[1] =~ s/\\040/ /gr;
				($Used, $Free) = (df($Mount))[2,3];
				$Used = $Used * 1024;
				$Free = $Free * 1024;
				$Size = $Free + $Used;
				$Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit){
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				}else{
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH);
	}
}

#--------------------------------------------------------------Finish & Summary

# This verbosity message is a bit out of place otherwise.
Info("Done.") unless $AlertCount > 0 and $ShowSummary eq 'true';

# Only show the summary if set to and actually have alerts. This should be
# particularly useful if the user logs UbuChk's output.
exit(0) unless $AlertCount > 0 and $ShowSummary eq 'true';

my $Time = localtime();
my $HostNameFile = '/etc/hostname';

FileChk($HostNameFile);
open(my $FH, '<', $HostNameFile);
chomp(my $Host = <$FH>);
close($FH);

print(qq{  Timestamp: $Time
	   Hostname: $Host
	   Username: $ENV{USER}
	     UserID: $<
	     Alerts: $AlertCount

} =~ tr/\t//dr)
